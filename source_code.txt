Project Path: interface

Source Tree:

```txt
interface
├── next-env.d.ts
├── server
│   └── src
│       ├── Aggregator
│       │   ├── constants.ts
│       │   ├── list.ts
│       │   ├── nativeTokens.ts
│       │   ├── rpcs.ts
│       │   └── types.ts
│       ├── fallback.ts
│       ├── generateTokenlist.ts
│       ├── getDexAggregatorQuote.ts
│       ├── submitSwap.ts
│       └── tokenlists
│           ├── constants.ts
│           ├── getTokenList.ts
│           ├── getTokensData.ts
│           ├── nativeTokens.ts
│           ├── ownTokenlist.ts
│           ├── s3.ts
│           ├── types.ts
│           └── utils.ts
└── src
    ├── components
    │   ├── Aggregator
    │   │   ├── adapters
    │   │   │   ├── 0x.ts
    │   │   │   ├── 0xGasless.ts
    │   │   │   ├── 0xV2.ts
    │   │   │   ├── 1inch.test.ts
    │   │   │   ├── 1inch.ts
    │   │   │   ├── airswap.ts
    │   │   │   ├── cowswap
    │   │   │   │   ├── abi.ts
    │   │   │   │   └── index.ts
    │   │   │   ├── firebird.ts
    │   │   │   ├── hashflow
    │   │   │   │   ├── abi.ts
    │   │   │   │   └── index.ts
    │   │   │   ├── krystal.ts
    │   │   │   ├── kyberswap.ts
    │   │   │   ├── lifi.ts
    │   │   │   ├── llamazip
    │   │   │   │   ├── encode.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   └── pairs.ts
    │   │   │   ├── odos
    │   │   │   │   └── index.ts
    │   │   │   ├── openocean.ts
    │   │   │   ├── paraswap.ts
    │   │   │   ├── rango.ts
    │   │   │   ├── unidex.ts
    │   │   │   ├── utils.ts
    │   │   │   └── yieldyak
    │   │   │       ├── abi.ts
    │   │   │       └── index.ts
    │   │   ├── chainToCoingeckoId.ts
    │   │   ├── claimAbi.ts
    │   │   ├── constants.ts
    │   │   ├── hooks
    │   │   │   ├── index.ts
    │   │   │   ├── useEstimateGas.ts
    │   │   │   └── useTokenApprove.ts
    │   │   ├── list.ts
    │   │   ├── nativeTokens.ts
    │   │   ├── router.ts
    │   │   ├── rpcs.ts
    │   │   ├── testAdapters.test.ts
    │   │   ├── types.ts
    │   │   └── utils
    │   │       ├── arbitrumFees.ts
    │   │       ├── getAllowance.ts
    │   │       ├── optimismFees.ts
    │   │       └── sendTx.ts
    │   └── WalletProvider
    │       ├── chains.ts
    │       └── index.ts
    ├── constants
    │   └── breakpoints.ts
    ├── hooks
    │   ├── index.ts
    │   └── useCountdown.ts
    ├── props
    │   ├── getLendingProps.ts
    │   ├── getSandwichList.ts
    │   ├── getTokenList.ts
    │   ├── getTokensMaps.ts
    │   └── getYieldsProps.ts
    ├── types.ts
    └── utils
        ├── formatAmount.ts
        └── formatToast.ts

```

`interface/next-env.d.ts`:

```ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

```

`interface/server/src/Aggregator/constants.ts`:

```ts
import { zeroAddress } from 'viem';

export const defillamaReferrerAddress = '0x08a3c2A819E3de7ACa384c798269B3Ce1CD0e437';
export const altReferralAddress = '0xa43C3EDe995AA058B68B882c6aF16863F18c5330';

export const chainsMap = {
	ethereum: 1,
	bsc: 56,
	polygon: 137,
	optimism: 10,
	arbitrum: 42161,
	avax: 43114,
	gnosis: 100,
	fantom: 250,
	klaytn: 8217,
	aurora: 1313161554,
	celo: 42220,
	cronos: 25,
	dogechain: 2000,
	moonriver: 1285,
	bttc: 199,
	oasis: 42262,
	velas: 106,
	heco: 128,
	harmony: 1666600000,
	boba: 288,
	okexchain: 66,
	fuse: 122,
	moonbeam: 1284,
	canto: 7700,
	zksync: 324,
	polygonzkevm: 1101,
	ontology: 58,
	kava: 2222,
	pulse: 369,
	metis: 1088,
	base: 8453,
	linea: 59144,
	mode: 34443,
	mantle: 5000,
	scroll: 534352,
	sonic: 146
} as const;

export const geckoChainsMap: Record<string, number> = {
	ethereum: 1,
	'binance-smart-chain': 56,
	'polygon-pos': 137,
	'optimistic-ethereum': 10,
	'arbitrum-one': 42161,
	avalanche: 43114,
	xdai: 100,
	fantom: 250,
	'klay-token': 8217,
	aurora: 1313161554,
	celo: 42220,
	cronos: 25,
	dogechain: 2000,
	moonriver: 1285,
	bittorrent: 199,
	oasis: 42262,
	velas: 106,
	heco: 128,
	'harmony-shard-0': 1666600000,
	boba: 288,
	'okex-chain': 66,
	fuse: 122,
	moonbeam: 1284,
	canto: 7700,
	'polygon-zkevm': 1101,
	zksync: 324,
	pulsechain: 369,
	kava: 2222,
	ontology: 58,
	'metis-andromeda': 1088,
	linea: 59144,
	base: 8453,
	mode: 34443,
	mantle: 5000,
	scroll: 534352,
	sonic: 146
};

export const chainGasToken: Record<keyof typeof chainsMap, string> = {
	ethereum: 'ethereum',
	bsc: 'binancecoin',
	polygon: 'matic-network',
	optimism: 'ethereum',
	arbitrum: 'ethereum',
	avax: 'avalanche-2',
	gnosis: 'xdai',
	fantom: 'fantom',
	klaytn: 'klay-token',
	aurora: 'ethereum',
	celo: 'celo',
	cronos: 'crypto-com-chain',
	dogechain: 'dogecoin',
	moonriver: 'moonriver',
	bttc: 'bittorrent',
	oasis: 'oasis-network',
	velas: 'velas',
	heco: 'huobi-token',
	harmony: 'harmony',
	boba: 'ethereum',
	okexchain: 'oec-token',
	fuse: 'fuse-network-token',
	moonbeam: 'moonbeam',
	canto: 'canto',
	zksync: 'ethereum',
	polygonzkevm: 'ethereum',
	ontology: 'ontology',
	kava: 'kava',
	pulse: 'pulsechain',
	metis: 'metis-token',
	base: 'ethereum',
	linea: 'ethereum',
	mode: 'ethereum',
	mantle: 'mantle',
	scroll: 'ethereum',
	sonic: 'sonic'
};

export const geckoTerminalChainsMap = {
	1: 'eth',
	56: 'bsc',
	137: 'polygon_pos',
	10: 'optimism',
	42161: 'arbitrum',
	43114: 'avax',
	100: 'gnosis',
	250: 'ftm',
	1313161554: 'aurora',
	42220: 'celo',
	25: 'cro',
	2000: 'dogechain',
	1285: 'movr',
	42262: 'oasis',
	106: 'velas',
	128: 'heco',
	1666600000: 'one',
	288: 'boba',
	66: 'okexchain',
	122: 'fuse',
	1284: 'glmr',
	199: 'bttc',
	8217: 'klaytn',
	7700: 'canto',
	2222: 'kava',
	369: 'pulsechain',
	1101: 'polygon-zkevm',
	324: 'zksync',
	1088: 'metis',
	8453: 'base',
	59144: 'linea'
};

export const chainIdToName = (chainId) => {
	return Object.entries(chainsMap).find(([, id]) => String(id) === String(chainId))?.[0];
};

export const chainNamesReplaced = {
	bsc: 'BSC',
	avax: 'Avalanche',
	okexchain: 'OKTChain',
	bttc: 'BitTorrent'
};

export const nativeAddress = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'.toLowerCase();

export const initialLiquidity = [500, 1_000, 10_000, 100_000, 1_000_000, 10_000_000, 100_000_000, 500_000_000];

export const WETH = {
	ethereum: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'.toLowerCase()
};
export const PRICE_IMPACT_MEDIUM_THRESHOLD = 5;
export const PRICE_IMPACT_HIGH_THRESHOLD = 10;
export const PRICE_IMPACT_WARNING_THRESHOLD = 3;

export const tokenApprovalAbi = [
	{
		constant: false,
		inputs: [
			{ name: '_spender', type: 'address' },
			{ name: '_value', type: 'uint256' }
		],
		name: 'approve',
		outputs: [],
		payable: false,
		stateMutability: 'nonpayable',
		type: 'function'
	}
] as const;

export const wrappedTokensByChain = {
	1: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // Ethereum: WETH
	56: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // BSC: WBNB
	137: '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // Polygon: WPOL
	10: '0x4200000000000000000000000000000000000006', // Optimism: WETH
	42161: '0x82af49447d8a07e3bd95bd0d56f35241523fbab1', // Arbitrum: WETH
	43114: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Avalanche: WAVAX
	100: '0xe91d153e0b41518a2ce8dd3d7944fa863463a97d', // Gnosis: WXDAI
	250: '0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83', // Fantom: WFTM
	8217: '0x19aac5f612f524b754ca7e7c41cbfa2e981a4432', // Klaytn: WKLAY
	1313161554: null, // Aurora
	42220: '0x2021B12D8138e2D63cF0895eccABC0DFc92416c6', // Celo: WCELO
	25: null, // Cronos
	2000: null, // Dogechain
	1285: '0x98878b06940ae243284ca214f92bb71a2b032b8a', // Moonriver: WMOVR
	199: '0x23181f21dea5936e24163ffaba4ea3b316b57f3c', // BitTorrent: WBTT
	106: null, // Velas
	128: null, // Heco
	1666600000: '0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a', // Harmony: WONE
	288: '0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000', // Boba: WETH
	66: '0x8F8526dbfd6E38E3D8307702cA8469Bae6C56C15', // OKX: WOKT
	122: '0x0BE9e53fd7EDaC9F859882AfdDa116645287C629', // Fuse: WFUSE
	1284: '0xacc15dc74880c9944775448304b263d191c6077f', // Moonbeam: WGLMR
	7700: '0x826551890dc65655a0aceca109ab11abdbd7a07b', // Canto: WCANTO
	324: '0xf00DAD97284D0c6F06dc4Db3c32454D4292c6813', // zkSync: WETH
	1101: '0x4F9A0e7FD2Bf6067db6994CF12E4495Df938E6e9', // Polygon zkEVM: WETH
	58: '0x219cc8e994ea6b35cdcffb5d44e229325d5ad02a', // Ontology: WONT
	2222: '0xc86c7C0eFbd6A49B35E8714C5f59D99De09A225b', // Kava: WKAVA
	369: '0xA1077a294dDE1B09bB078844df40758a5D0f9a27', // PulseChain: WPLS
	1088: '0x75cb093E4D61d2A2e65D8e0BBb01DE8d89b53481', // Metis: WMETIS
	8453: '0x4200000000000000000000000000000000000006', // Base: WETH
	59144: '0xe5d7c2a44ffddf6b295a15c148167daaaf5cf34f', // Linea: WETH
	34443: '0x4200000000000000000000000000000000000006', // Mode: WETH
	5000: '0x78c1b0c915c4faa5fffa6cabf0219da63d7f4cb8', // Mantle: WMNT
	534352: '0x5300000000000000000000000000000000000004', // Scroll: WETH
	146: '0x039e2fb66102314ce7b64ce5ce3e5183bc94ad38' // Sonic: wS
} as const;

export const topTokensByChain = {
	1: [
		zeroAddress, // ETH
		'0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC
		'0xdac17f958d2ee523a2206206994597c13d831ec7', // USDT
		'0x2260fac5e5542a773aa44fbcfedf7c193bc2c599', // WBTC
		'0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2' // WETH
	],
	56: [
		zeroAddress, // BNB
		'0x55d398326f99059ff775485246999027b3197955', // USDT
		'0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d', // USDC
		'0x2170ed0880ac9a755fd29b2688956bd959f933f8' // ETH
	],
	137: [
		zeroAddress, // POL
		'0x3c499c542cef5e3811e1192ce70d8cc03d5c3359', // USDC
		'0xc2132d05d31c914a87c6611c10748aeb04b58e8f', // USDT
		'0x7ceb23fd6bc0add59e62ac25578270cff1b9f619' // WETH
	],
	10: [
		zeroAddress, // ETH
		'0x0b2c639c533813f4aa9d7837caf62653d097ff85', // USDC
		'0x94b008aa00579c1307b0ef2c499ad98a8ce58e58', // USDT
		'0x4200000000000000000000000000000000000042' // OP
	],
	42161: [
		zeroAddress, // ETH
		'0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9', // USDT
		'0xaf88d065e77c8cc2239327c5edb3a432268e5831', // USDC
		'0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f' // WBTC
	],
	43114: [
		zeroAddress, // AVAX
		'0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7', // USDT
		'0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e', // USDC
		'0x152b9d0FdC40C096757F570A51E494bd4b943E50' // BTC.b
	],
	100: [
		zeroAddress, // XDAI
		'0x4ecaba5870353805a9f068101a40e0f32ed605c6', // USDT
		'0xddafbb505ad214d7b80b1f830fccc89b60fb7a83', // USDC
		'0x6a023ccd1ff6f2045c3309768ead9e68f978f6e1' // WETH
	],
	250: [],
	8217: [],
	1313161554: [],
	42220: [],
	25: [],
	2000: [],
	1285: [],
	199: [],
	106: [],
	128: [],
	1666600000: [],
	288: [],
	66: [],
	122: [],
	1284: [],
	7700: [],
	324: [
		'0x000000000000000000000000000000000000800A', // ETH
		'0x1d17CBcF0D6D143135aE902365D2E5e2A16538D4', // USDC
		'0x5A7d6b2F92C77FAD6CCaBd7EE0624E64907Eaf3E' // ZK
	],
	1101: [
		zeroAddress, // ETH
		'0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035', // USDC
		'0x1e4a5963abfd975d8c9021ce480b42188849d41d', // USDT
		'0x22b21beddef74fe62f031d2c5c8f7a9f8a4b304d' // POL
	],
	58: [],
	2222: [],
	369: [],
	1088: [],
	8453: [
		zeroAddress, // ETH
		'0x833589fcd6edb6e08f4c7c32d4f71b54bda02913', // USDC
		'0x820c137fa70c8691f0e44dc420a5e53c168921dc', // USDS
		'0xcbb7c0000ab88b473b1f5afd9ef808440eed33bf' // cbBTC
	],
	59144: [
		zeroAddress, // ETH
		'0xa219439258ca9da29e9cc4ce5596924745e12b93', // USDT
		'0x176211869ca2b568f2a7d4ee941e073a821ee1ff', // USDC
		'0x3aab2285ddcddad8edf438c1bab47e1a9d05a9b4' // WBTC
	],
	34443: [],
	5000: [],
	534352: [
		zeroAddress, // ETH
		'0xf55bec9cafdbe8730f096aa55dad6d22d44099df', // USDT
		'0x06efdbff2a14a7c8e15944d1f4a48f9f95f663a4', // USDC
		'0x3c1bca5a656e69edcd0d4e36bebb3fcdaca60cf1', // WBTC
		'0x5300000000000000000000000000000000000004' // WETH
	],
	146: [
		zeroAddress, // S
		'0x29219dd400f2bf60e5a23d13be72b486d4038894', // USDC.e
		'0x039e2fb66102314ce7b64ce5ce3e5183bc94ad38', // wS
		'0x50c42deacd8fc9773493ed674b675be577f2634b' // WETH
	]
};

```

`interface/server/src/Aggregator/list.ts`:

```ts
import * as matcha from './adapters/0x';
import * as inch from './adapters/1inch';
import * as cowswap from './adapters/cowswap';
//import * as firebird from './adapters/firebird';
import * as kyberswap from './adapters/kyberswap';
//import * as hashflow from './adapters/hashflow';
//import * as openocean from './adapters/openocean';
import * as paraswap from './adapters/paraswap';
// import * as lifi from './adapters/lifi';
// import * as rango from './adapters/rango';

// import * as unidex from "./adapters/unidex" - disabled, their api is broken
// import * as airswap from './adapters/airswap' cors
import * as odos from './adapters/odos';
// import * as yieldyak from './adapters/yieldyak';
// import * as llamazip from './adapters/llamazip';
// import * as krystal from './adapters/krystal'
import * as matchaGasless from './adapters/0xGasless';
import * as matchaV2 from './adapters/0xV2';

export const adapters = [matcha, cowswap, paraswap, kyberswap, inch, matchaGasless, odos, matchaV2];

export const inifiniteApprovalAllowed = [matcha.name, cowswap.name, matchaGasless.name];

export const adaptersWithApiKeys = {
	[matcha.name]: true,
	[matchaGasless.name]: true,
	[matchaV2.name]: true,
	[inch.name]: true,
	//[hashflow.name]: true
};

```

`interface/server/src/Aggregator/nativeTokens.ts`:

```ts
import { zeroAddress } from 'viem';

const ICONS_CDN = 'https://icons.llamao.fi/icons';
export function chainIconUrl(chain) {
	return `${ICONS_CDN}/chains/rsz_${chain.toLowerCase()}?w=48&h=48`;
}

const ethereum = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const binance = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 56,
	name: 'Binance',
	symbol: 'BNB',
	logoURI: chainIconUrl('binance'),
	decimals: 18
};

const arbitrum = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 42161,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const optimism = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 10,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const base = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 8453,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const linea = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 59144,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const scroll = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 534352,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const okx = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 66,
	name: 'OKX',
	symbol: 'OKX',
	logoURI: chainIconUrl('okexchain'),
	decimals: 18
};

const boba = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 288,
	logoURI: chainIconUrl('ethereum'),
	name: 'Ethereum',
	symbol: 'ETH',
	decimals: 18
};

const harmony = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1666600000,
	logoURI: chainIconUrl('harmony'),
	decimals: 18,
	name: 'Harmony',
	symbol: 'ONE'
};

const heco = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 128,
	logoURI: chainIconUrl('heco'),
	name: 'Huobi Token',
	symbol: 'HT',
	decimals: 18
};

const velas = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 106,
	logoURI: chainIconUrl('velas'),
	name: 'Velas',
	symbol: 'VLX',
	decimals: 18
};

const oasis = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 24462,
	name: 'Oasis',
	symbol: 'ROSE',
	logoURI: chainIconUrl('oasis'),
	decimals: 18
};

const bttc = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 199,
	name: 'BitTorrent',
	logoURI: chainIconUrl('bittorrent'),
	symbol: 'BTT',
	decimals: 18
};

const moonriver = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1285,
	name: 'MoonRiver',
	logoURI: chainIconUrl('moonriver'),
	symbol: 'MOVR',
	decimals: 18
};

const moonbeam = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1284,
	name: 'Moonbeam',
	logoURI: chainIconUrl('moonbeam'),
	symbol: 'GLMR',
	decimals: 18
};

const fuse = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 122,
	name: 'Fuse',
	logoURI: chainIconUrl('fuse'),
	symbol: 'FUSE',
	decimals: 18
};

const dogechain = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 2000,
	name: 'Doge',
	symbol: 'DOGE',
	decimals: 18,
	logoURI: chainIconUrl('dogechain')
};

const cronos = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 25,
	name: 'Cronos',
	symbol: 'CRO',
	logoURI: chainIconUrl('cronos'),
	decimals: 18
};
const celo = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 42220,
	name: 'Celo',
	symbol: 'CELO',
	logoURI: chainIconUrl('celo'),
	decimals: 18
};
const aurora = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1313161554,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};
const avax = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 43114,
	logoURI: chainIconUrl('avax'),
	name: 'Avalanche',
	symbol: 'AVAX',
	decimals: 18
};

const klaytn = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 8217,
	name: 'Klaytn',
	symbol: 'KLAY',
	logoURI: chainIconUrl('klaytn'),
	decimals: 18
};
const fantom = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 250,
	logoURI: chainIconUrl('fantom'),
	name: 'Fantom',
	symbol: 'FTM',
	decimals: 18
};

const gnosis = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 100,
	name: 'xDai',
	symbol: 'xDai',
	logoURI: chainIconUrl('gnosis'),
	decimals: 18
};
const polygon = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 137,
	name: 'Polygon',
	symbol: 'POL',
	logoURI: chainIconUrl('polygon'),
	decimals: 18
};

const canto = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 7700,
	name: 'Canto',
	symbol: 'CANTO',
	logoURI: chainIconUrl('canto'),
	decimals: 18
};

const metis = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1088,
	name: 'Metis',
	symbol: 'METIS',
	logoURI: chainIconUrl('metis'),
	decimals: 18
};

const polygonzkevm = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1101,
	name: 'Polygon zkEVM',
	symbol: 'ETH',
	logoURI: chainIconUrl('polygon zkevm'),
	decimals: 18
};

const kava = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 2222,
	name: 'Kava',
	symbol: 'KAVA',
	logoURI: chainIconUrl('kava'),
	decimals: 18
};

const zksync = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 324,
	name: 'zkSync Era',
	symbol: 'ETH',
	logoURI: chainIconUrl('zksync era'),
	decimals: 18
};

const ontology = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 58,
	name: 'Ontology',
	symbol: 'ONT',
	logoURI: chainIconUrl('ontologyevm'),
	decimals: 18
};

const pulse = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 369,
	name: 'Pulse',
	symbol: 'PLS',
	logoURI: chainIconUrl('pulse'),
	decimals: 18
};

const sonic = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 146,
	name: 'SONIC',
	symbol: 's',
	logoURI: chainIconUrl('sonic'),
	decimals: 18
};

export const nativeTokens = [
	ethereum,
	arbitrum,
	binance,
	optimism,
	polygon,
	oasis,
	fantom,
	velas,
	harmony,
	gnosis,
	klaytn,
	avax,
	aurora,
	cronos,
	celo,
	dogechain,
	moonriver,
	bttc,
	heco,
	boba,
	okx,
	moonbeam,
	fuse,
	canto,
	metis,
	polygonzkevm,
	kava,
	zksync,
	ontology,
	pulse,
	base,
	linea,
	scroll,
	sonic
];

```

`interface/server/src/Aggregator/rpcs.ts`:

```ts
import { uniq } from 'lodash';
import { fallback, http } from 'wagmi';


const getLlamaRpc = (chain:string) => `https://rpc.llama-rpc.com/${chain}?source=llamaswap`

export const rpcUrls: Record<number, Array<string>> = {
	1: [
		getLlamaRpc("ethereum"),
		'https://cloudflare-eth.com',
		'https://rpc.flashbots.net',
		'https://rpc.builder0x69.io',
		'https://ethereum.publicnode.com',
		'https://eth-mainnet.public.blastapi.io'
	],
	56: [
		getLlamaRpc("bsc"),
		'https://bsc-dataseed.binance.org',
		'https://bsc-dataseed1.defibit.io',
		'https://bsc-dataseed1.ninicoin.io',
		'https://bsc-dataseed2.defibit.io',
		'https://bsc-dataseed2.ninicoin.io'
	],
	137: [
		getLlamaRpc("polygon"),
		'https://rpc-mainnet.matic.quiknode.pro',
		'https://polygon-rpc.com',
		'https://polygon-bor-rpc.publicnode.com',
		'https://endpoints.omniatech.io/v1/matic/mainnet/public'
	],
	128: [getLlamaRpc("heco"), 'https://http-mainnet.hecochain.com'],
	250: [getLlamaRpc("fantom"), 'https://rpcapi.fantom.network', 'https://rpc2.fantom.network', 'https://fantom-rpc.publicnode.com'],
	30: [getLlamaRpc("rsk"), 'https://public-node.rsk.co'],
	88: [getLlamaRpc("tomochain"), 'https://rpc.tomochain.com'],
	100: [getLlamaRpc("xdai"), 'https://rpc.gnosischain.com', 'https://gnosis-mainnet.public.blastapi.io'],
	43114: [
		getLlamaRpc("avax"),
		'https://api.avax.network/ext/bc/C/rpc',
		'https://ava-mainnet.public.blastapi.io/ext/bc/C/rpc',
		'https://endpoints.omniatech.io/v1/avax/mainnet/public'
	],
	888: [getLlamaRpc("wan"), 'https://gwan-ssl.wandevs.org:56891'],
	1666600000: [
		getLlamaRpc("harmony"),
		'https://harmony-0-rpc.gateway.pokt.network',
		'https://api.harmony.one',
		'https://api.s0.t.hmny.io',
		'https://harmony-mainnet.chainstacklabs.com'
	],
	108: [getLlamaRpc("thundercore"), 'https://mainnet-rpc.thundercore.com'],
	66: [getLlamaRpc("okexchain"), 'https://exchainrpc.okex.org'],
	10: [
		getLlamaRpc("optimism"),
		'https://mainnet.optimism.io',
		'https://optimism-mainnet.public.blastapi.io',
		'https://endpoints.omniatech.io/v1/op/mainnet/public'
	],
	42161: [
		getLlamaRpc("arbitrum"),
		'https://arb1.arbitrum.io/rpc',
		'https://arbitrum-one.public.blastapi.io',
		'https://arb1.lava.build'
	],
	321: [getLlamaRpc("kcc"), 'https://rpc-mainnet.kcc.network'],
	42220: [getLlamaRpc("celo"), 'https://forno.celo.org'],
	4689: [getLlamaRpc("iotex"), 'https://babel-api.mainnet.iotex.io'],
	1285: [getLlamaRpc("moonriver"), 'https://rpc.api.moonriver.moonbeam.network', 'https://moonriver.api.onfinality.io/public'],
	336: [
		getLlamaRpc("shiden"),
		'https://shiden.api.onfinality.io/public',
		'https://rpc.shiden.astar.network:8545'
	],
	11297108109: [getLlamaRpc("palm"), 'https://palm-mainnet.infura.io/v3/3a961d6501e54add9a41aa53f15de99b'],
	246: [getLlamaRpc("energyweb"), 'https://rpc.energyweb.org'],
	39797: [getLlamaRpc("energi"), 'https://nodeapi.energi.network'],
	19: [getLlamaRpc("songbird"), 'https://songbird.towolabs.com/rpc'],
	269: [getLlamaRpc("hpb"), 'https://hpbnode.com'],
	60: [getLlamaRpc("gochain"), 'https://rpc.gochain.io'],
	61: [getLlamaRpc("ethereumclassic"), 'https://www.ethercluster.com/etc', 'https://blockscout.com/etc/mainnet/api/eth-rpc'],
	200: [getLlamaRpc("xdaiarb"), 'https://arbitrum.xdaichain.com'],
	24: [getLlamaRpc("kardia"), 'https://rpc.kardiachain.io'],
	122: [getLlamaRpc("fuse"), 'https://rpc.fuse.io'],
	10000: [getLlamaRpc("smartbch"), 'https://smartbch.fountainhead.cash/mainnet'],
	20: [getLlamaRpc("elastos"), 'https://api.elastos.io/eth', 'https://api.trinity-tech.cn/eth'],
	70: [getLlamaRpc("hoo"), 'https://http-mainnet.hoosmartchain.com'],
	32659: [getLlamaRpc("fusion"), 'https://mainnet.anyswap.exchange'],
	1313161554: [getLlamaRpc("aurora"), 'https://mainnet.aurora.dev'],
	2020: [getLlamaRpc("ronin"), 'https://api.roninchain.com/rpc'],
	288: [getLlamaRpc("boba"), 'https://mainnet.boba.network'],
	25: [
		getLlamaRpc("cronos"),
		'https://cronosrpc-1.xstaking.sg',
		'https://evm.cronos.org',
		'https://rpc.vvs.finance',
		'https://evm-cronos.crypto.org'
	],
	333999: [getLlamaRpc("polis"), 'https://rpc.polis.tech'],
	55: [
		getLlamaRpc("zyx"),
		'https://rpc-1.zyx.network',
		'https://rpc-2.zyx.network',
		'https://rpc-2.zyx.network',
		'https://rpc-5.zyx.network'
	],
	40: [getLlamaRpc("telos"), 'https://mainnet.telos.net/evm', 'https://rpc1.eu.telos.net/evm', 'https://rpc1.us.telos.net/evm'],
	1088: [getLlamaRpc("metis"), 'https://andromeda.metis.io/?owner=1088'],
	8: [getLlamaRpc("ubiq"), 'https://rpc.octano.dev'],
	106: [getLlamaRpc("velas"), 'https://evmexplorer.velas.com/rpc'],
	820: [getLlamaRpc("callisto"), 'https://rpc.callisto.network', 'https://clo-geth.0xinfra.com'],
	8217: [getLlamaRpc("klaytn"), 'https://public-node-api.klaytnapi.com/v1/cypress'],
	52: [
		getLlamaRpc("csc"),
		'https://rpc.coinex.net',
		'https://rpc1.coinex.net',
		'https://rpc2.coinex.net',
		'https://rpc3.coinex.net',
		'https://rpc4.coinex.net'
	],
	5551: [getLlamaRpc("nahmii"), 'https://l2.nahmii.io'],
	5050: [getLlamaRpc("liquidchain"), 'https://rpc.liquidchain.net', 'https://rpc.xlcscan.com'],
	82: [getLlamaRpc("meter"), 'https://rpc.meter.io'],
	361: [getLlamaRpc("theta"), 'https://eth-rpc-api.thetatoken.org/rpc'],
	42262: [getLlamaRpc("oasis"), 'https://emerald.oasis.dev'],
	57: [getLlamaRpc("syscoin"), 'https://rpc.syscoin.org'],
	1284: [getLlamaRpc("moonbeam"), 'https://rpc.api.moonbeam.network'],
	836542336838601: [getLlamaRpc("curio"), 'https://mainnet-api.skalenodes.com/v1/fit-betelgeuse'],
	592: [getLlamaRpc("astar"), 'https://evm.astar.network', 'https://rpc.astar.network:8545', 'https://astar.api.onfinality.io/public'],
	7700: [getLlamaRpc("canto"), 'https://canto.slingshot.finance', 'https://canto.neobase.one', 'https://mainnode.plexnode.org:8545'],
	324: [getLlamaRpc("era"), 'https://mainnet.era.zksync.io'],
	58: [getLlamaRpc("ontology_evm"), 'http://dappnode4.ont.io:20339', 'http://dappnode3.ont.io:20339'],
	1101: [getLlamaRpc("polygon_zkevm"), 'https://zkevm-rpc.com'],
	2222: [getLlamaRpc("kava"), 'https://evm2.kava.io'],
	369: [getLlamaRpc("pulse"), 'https://rpc.pulsechain.com'],
	8453: [getLlamaRpc("base"), 'https://mainnet.base.org', 'https://base-rpc.publicnode.com', 'https://base-mainnet.public.blastapi.io'],
	59144: [getLlamaRpc("linea"), 'https://rpc.linea.build'],
	534352: [getLlamaRpc("scroll"), 'https://rpc.scroll.io', 'https://scroll-mainnet.public.blastapi.io'],
	146: [getLlamaRpc("sonic"), 'https://rpc.soniclabs.com', 'https://sonic-rpc.publicnode.com']
};

export const rpcsTransports = Object.fromEntries(
	Object.entries(rpcUrls).map((chain: [string, Array<string>]) => [
		chain[0],
		fallback(uniq(chain[1]).map((rpc) => http(rpc, { timeout: 3_000 })))
	])
);

```

`interface/server/src/Aggregator/types.ts`:

```ts
export interface ExtraData {
	userAddress: string;
	slippage: string;
	amountOut: string;
}

```

`interface/server/src/fallback.ts`:

```ts
const handler = async (
  event: AWSLambda.APIGatewayEvent
): Promise<any> => {
  if(event.httpMethod === "OPTIONS"){
    return {
      statusCode: 200,
      body: "",
      headers: {
        "cache-control": "max-age=3600, s-maxage=3600", // Caches preflight req on browser and proxy for 1 hour
        "access-control-allow-methods": "OPTIONS,GET",
        "access-control-allow-headers":
          "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,X-Amz-User-Agent",
        "Access-Control-Allow-Origin": "*",
      },
    };
  }
  const response = {
    statusCode: 404,
    body: "This endpoint doesn't exist",
    headers: {
        "Cache-Control": `max-age=${3600}`,
        "Access-Control-Allow-Origin": "*",
    }
  }

  return response;
};

export default handler;

```

`interface/server/src/generateTokenlist.ts`:

```ts
import { getTokenList } from './tokenlists/getTokenList';
import { storeJSONString } from './tokenlists/s3';

const handler = async () => {
	try {
		const tokenlists = await getTokenList();
		await storeJSONString('tokenlists.json', JSON.stringify(tokenlists), 3600);
		// store token list by chain
		for (const chain in tokenlists) {
			const list = {}
			for (const token of tokenlists[chain]) {
				list[token.address] = token;
			}
			await storeJSONString(`tokenlists-${chain}.json`, JSON.stringify(list), 3600);
		}
	} catch (e) {
		console.log(e);
		throw e;
	}
};

export default handler;
```

`interface/server/src/getDexAggregatorQuote.ts`:

```ts
import { adapters } from './Aggregator/list';

const handler = async (event: AWSLambda.APIGatewayEvent): Promise<any> => {
	const { protocol, chain, from, to, amount } = event.queryStringParameters!;
	const body = JSON.parse(event.body!);
	const agg = adapters.find((ag) => ag.name === protocol);
	if (agg === undefined) {
		return {
			statusCode: 404,
			body: JSON.stringify({ message: 'No DEX Aggregator with that name' }),
			headers: {
				'Cache-Control': `max-age=${3600}`,
				'Access-Control-Allow-Origin': '*'
			}
		};
	}
	const quote = await agg.getQuote(chain!, from!, to!, amount!, body!);
	return {
		statusCode: 200,
		body: JSON.stringify(quote),
		headers: {
			'Cache-Control': `max-age=${10}`,
			'Access-Control-Allow-Origin': '*'
		}
	};
};

export default handler;

```

`interface/server/src/submitSwap.ts`:

```ts
import { adapters } from './Aggregator/list';

const handler = async (event: AWSLambda.APIGatewayEvent): Promise<any> => {
	const { protocol, chain } = event.queryStringParameters!;
	const body = JSON.parse(event.body!);
	const agg = adapters.find((ag) => ag.name === protocol);
	if (agg === undefined) {
		return {
			statusCode: 404,
			body: JSON.stringify({ message: 'No DEX Aggregator with that name' }),
			headers: {
				'Cache-Control': `max-age=${3600}`,
				'Access-Control-Allow-Origin': '*'
			}
		};
	}
	if (!(agg as any).submitSwap) {
		return {
			statusCode: 400,
			body: JSON.stringify({ message: "Aggregator doesn't support submitting swap" }),
			headers: {
				'Cache-Control': `max-age=${3600}`,
				'Access-Control-Allow-Origin': '*'
			}
		};
	}
	const res = await (agg as any).submitSwap({ chain, body });
	return {
		statusCode: 200,
		body: JSON.stringify(res),
		headers: {
			'Access-Control-Allow-Origin': '*'
		}
	};
};

export default handler;

```

`interface/server/src/tokenlists/constants.ts`:

```ts
import { zeroAddress } from 'viem';

export const defillamaReferrerAddress = '0x08a3c2A819E3de7ACa384c798269B3Ce1CD0e437';
export const altReferralAddress = '0xa43C3EDe995AA058B68B882c6aF16863F18c5330';

export const chainsMap = {
	ethereum: 1,
	bsc: 56,
	polygon: 137,
	optimism: 10,
	arbitrum: 42161,
	avax: 43114,
	gnosis: 100,
	fantom: 250,
	klaytn: 8217,
	aurora: 1313161554,
	celo: 42220,
	cronos: 25,
	dogechain: 2000,
	moonriver: 1285,
	bttc: 199,
	oasis: 42262,
	velas: 106,
	heco: 128,
	harmony: 1666600000,
	boba: 288,
	okexchain: 66,
	fuse: 122,
	moonbeam: 1284,
	canto: 7700,
	zksync: 324,
	polygonzkevm: 1101,
	ontology: 58,
	kava: 2222,
	pulse: 369,
	metis: 1088,
	base: 8453,
	linea: 59144,
	mode: 34443,
	mantle: 5000,
	scroll: 534352,
	sonic: 146
} as const;

export const geckoChainsMap: Record<string, number> = {
	ethereum: 1,
	'binance-smart-chain': 56,
	'polygon-pos': 137,
	'optimistic-ethereum': 10,
	'arbitrum-one': 42161,
	avalanche: 43114,
	xdai: 100,
	fantom: 250,
	'klay-token': 8217,
	aurora: 1313161554,
	celo: 42220,
	cronos: 25,
	dogechain: 2000,
	moonriver: 1285,
	bittorrent: 199,
	oasis: 42262,
	velas: 106,
	heco: 128,
	'harmony-shard-0': 1666600000,
	boba: 288,
	'okex-chain': 66,
	fuse: 122,
	moonbeam: 1284,
	canto: 7700,
	'polygon-zkevm': 1101,
	zksync: 324,
	pulsechain: 369,
	kava: 2222,
	ontology: 58,
	'metis-andromeda': 1088,
	linea: 59144,
	base: 8453,
	mode: 34443,
	mantle: 5000,
	scroll: 534352,
	sonic: 146
};

export const chainGasToken: Record<keyof typeof chainsMap, string> = {
	ethereum: 'ethereum',
	bsc: 'binancecoin',
	polygon: 'matic-network',
	optimism: 'ethereum',
	arbitrum: 'ethereum',
	avax: 'avalanche-2',
	gnosis: 'xdai',
	fantom: 'fantom',
	klaytn: 'klay-token',
	aurora: 'ethereum',
	celo: 'celo',
	cronos: 'crypto-com-chain',
	dogechain: 'dogecoin',
	moonriver: 'moonriver',
	bttc: 'bittorrent',
	oasis: 'oasis-network',
	velas: 'velas',
	heco: 'huobi-token',
	harmony: 'harmony',
	boba: 'ethereum',
	okexchain: 'oec-token',
	fuse: 'fuse-network-token',
	moonbeam: 'moonbeam',
	canto: 'canto',
	zksync: 'ethereum',
	polygonzkevm: 'ethereum',
	ontology: 'ontology',
	kava: 'kava',
	pulse: 'pulsechain',
	metis: 'metis-token',
	base: 'ethereum',
	linea: 'ethereum',
	mode: 'ethereum',
	mantle: 'mantle',
	scroll: 'ethereum',
	sonic: 'sonic'
};

export const geckoTerminalChainsMap = {
	1: 'eth',
	56: 'bsc',
	137: 'polygon_pos',
	10: 'optimism',
	42161: 'arbitrum',
	43114: 'avax',
	100: 'gnosis',
	250: 'ftm',
	1313161554: 'aurora',
	42220: 'celo',
	25: 'cro',
	2000: 'dogechain',
	1285: 'movr',
	42262: 'oasis',
	106: 'velas',
	128: 'heco',
	1666600000: 'one',
	288: 'boba',
	66: 'okexchain',
	122: 'fuse',
	1284: 'glmr',
	199: 'bttc',
	8217: 'klaytn',
	7700: 'canto',
	2222: 'kava',
	369: 'pulsechain',
	1101: 'polygon-zkevm',
	324: 'zksync',
	1088: 'metis',
	8453: 'base',
	59144: 'linea'
};

export const chainIdToName = (chainId) => {
	return Object.entries(chainsMap).find(([, id]) => String(id) === String(chainId))?.[0];
};

export const chainNamesReplaced = {
	bsc: 'BSC',
	avax: 'Avalanche',
	okexchain: 'OKTChain',
	bttc: 'BitTorrent'
};

export const nativeAddress = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'.toLowerCase();

export const initialLiquidity = [500, 1_000, 10_000, 100_000, 1_000_000, 10_000_000, 100_000_000, 500_000_000];

export const WETH = {
	ethereum: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'.toLowerCase()
};
export const PRICE_IMPACT_MEDIUM_THRESHOLD = 5;
export const PRICE_IMPACT_HIGH_THRESHOLD = 10;
export const PRICE_IMPACT_WARNING_THRESHOLD = 3;

export const tokenApprovalAbi = [
	{
		constant: false,
		inputs: [
			{ name: '_spender', type: 'address' },
			{ name: '_value', type: 'uint256' }
		],
		name: 'approve',
		outputs: [],
		payable: false,
		stateMutability: 'nonpayable',
		type: 'function'
	}
] as const;

export const wrappedTokensByChain = {
	1: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // Ethereum: WETH
	56: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // BSC: WBNB
	137: '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // Polygon: WPOL
	10: '0x4200000000000000000000000000000000000006', // Optimism: WETH
	42161: '0x82af49447d8a07e3bd95bd0d56f35241523fbab1', // Arbitrum: WETH
	43114: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Avalanche: WAVAX
	100: '0xe91d153e0b41518a2ce8dd3d7944fa863463a97d', // Gnosis: WXDAI
	250: '0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83', // Fantom: WFTM
	8217: '0x19aac5f612f524b754ca7e7c41cbfa2e981a4432', // Klaytn: WKLAY
	1313161554: null, // Aurora
	42220: '0x2021B12D8138e2D63cF0895eccABC0DFc92416c6', // Celo: WCELO
	25: null, // Cronos
	2000: null, // Dogechain
	1285: '0x98878b06940ae243284ca214f92bb71a2b032b8a', // Moonriver: WMOVR
	199: '0x23181f21dea5936e24163ffaba4ea3b316b57f3c', // BitTorrent: WBTT
	106: null, // Velas
	128: null, // Heco
	1666600000: '0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a', // Harmony: WONE
	288: '0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000', // Boba: WETH
	66: '0x8F8526dbfd6E38E3D8307702cA8469Bae6C56C15', // OKX: WOKT
	122: '0x0BE9e53fd7EDaC9F859882AfdDa116645287C629', // Fuse: WFUSE
	1284: '0xacc15dc74880c9944775448304b263d191c6077f', // Moonbeam: WGLMR
	7700: '0x826551890dc65655a0aceca109ab11abdbd7a07b', // Canto: WCANTO
	324: '0xf00DAD97284D0c6F06dc4Db3c32454D4292c6813', // zkSync: WETH
	1101: '0x4F9A0e7FD2Bf6067db6994CF12E4495Df938E6e9', // Polygon zkEVM: WETH
	58: '0x219cc8e994ea6b35cdcffb5d44e229325d5ad02a', // Ontology: WONT
	2222: '0xc86c7C0eFbd6A49B35E8714C5f59D99De09A225b', // Kava: WKAVA
	369: '0xA1077a294dDE1B09bB078844df40758a5D0f9a27', // PulseChain: WPLS
	1088: '0x75cb093E4D61d2A2e65D8e0BBb01DE8d89b53481', // Metis: WMETIS
	8453: '0x4200000000000000000000000000000000000006', // Base: WETH
	59144: '0xe5d7c2a44ffddf6b295a15c148167daaaf5cf34f', // Linea: WETH
	34443: '0x4200000000000000000000000000000000000006', // Mode: WETH
	5000: '0x78c1b0c915c4faa5fffa6cabf0219da63d7f4cb8', // Mantle: WMNT
	534352: '0x5300000000000000000000000000000000000004', // Scroll: WETH
	146: '0x039e2fb66102314ce7b64ce5ce3e5183bc94ad38' // Sonic: wS
} as const;

export const topTokensByChain = {
	1: [
		zeroAddress, // ETH
		'0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC
		'0xdac17f958d2ee523a2206206994597c13d831ec7', // USDT
		'0x2260fac5e5542a773aa44fbcfedf7c193bc2c599', // WBTC
		'0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2' // WETH
	],
	56: [
		zeroAddress, // BNB
		'0x55d398326f99059ff775485246999027b3197955', // USDT
		'0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d', // USDC
		'0x2170ed0880ac9a755fd29b2688956bd959f933f8' // ETH
	],
	137: [
		zeroAddress, // POL
		'0x3c499c542cef5e3811e1192ce70d8cc03d5c3359', // USDC
		'0xc2132d05d31c914a87c6611c10748aeb04b58e8f', // USDT
		'0x7ceb23fd6bc0add59e62ac25578270cff1b9f619' // WETH
	],
	10: [
		zeroAddress, // ETH
		'0x0b2c639c533813f4aa9d7837caf62653d097ff85', // USDC
		'0x94b008aa00579c1307b0ef2c499ad98a8ce58e58', // USDT
		'0x4200000000000000000000000000000000000042' // OP
	],
	42161: [
		zeroAddress, // ETH
		'0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9', // USDT
		'0xaf88d065e77c8cc2239327c5edb3a432268e5831', // USDC
		'0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f' // WBTC
	],
	43114: [
		zeroAddress, // AVAX
		'0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7', // USDT
		'0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e', // USDC
		'0x152b9d0FdC40C096757F570A51E494bd4b943E50' // BTC.b
	],
	100: [
		zeroAddress, // XDAI
		'0x4ecaba5870353805a9f068101a40e0f32ed605c6', // USDT
		'0xddafbb505ad214d7b80b1f830fccc89b60fb7a83', // USDC
		'0x6a023ccd1ff6f2045c3309768ead9e68f978f6e1' // WETH
	],
	250: [],
	8217: [],
	1313161554: [],
	42220: [],
	25: [],
	2000: [],
	1285: [],
	199: [],
	106: [],
	128: [],
	1666600000: [],
	288: [],
	66: [],
	122: [],
	1284: [],
	7700: [],
	324: [
		'0x000000000000000000000000000000000000800A', // ETH
		'0x1d17CBcF0D6D143135aE902365D2E5e2A16538D4', // USDC
		'0x5A7d6b2F92C77FAD6CCaBd7EE0624E64907Eaf3E' // ZK
	],
	1101: [
		zeroAddress, // ETH
		'0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035', // USDC
		'0x1e4a5963abfd975d8c9021ce480b42188849d41d', // USDT
		'0x22b21beddef74fe62f031d2c5c8f7a9f8a4b304d' // POL
	],
	58: [],
	2222: [],
	369: [],
	1088: [],
	8453: [
		zeroAddress, // ETH
		'0x833589fcd6edb6e08f4c7c32d4f71b54bda02913', // USDC
		'0x820c137fa70c8691f0e44dc420a5e53c168921dc', // USDS
		'0xcbb7c0000ab88b473b1f5afd9ef808440eed33bf' // cbBTC
	],
	59144: [
		zeroAddress, // ETH
		'0xa219439258ca9da29e9cc4ce5596924745e12b93', // USDT
		'0x176211869ca2b568f2a7d4ee941e073a821ee1ff', // USDC
		'0x3aab2285ddcddad8edf438c1bab47e1a9d05a9b4' // WBTC
	],
	34443: [],
	5000: [],
	534352: [
		zeroAddress, // ETH
		'0xf55bec9cafdbe8730f096aa55dad6d22d44099df', // USDT
		'0x06efdbff2a14a7c8e15944d1f4a48f9f95f663a4', // USDC
		'0x3c1bca5a656e69edcd0d4e36bebb3fcdaca60cf1', // WBTC
		'0x5300000000000000000000000000000000000004' // WETH
	],
	146: [
		zeroAddress, // S
		'0x29219dd400f2bf60e5a23d13be72b486d4038894', // USDC.e
		'0x039e2fb66102314ce7b64ce5ce3e5183bc94ad38', // wS
		'0x50c42deacd8fc9773493ed674b675be577f2634b' // WETH
	]
};

```

`interface/server/src/tokenlists/getTokenList.ts`:

```ts
import { groupBy, mapValues, uniqBy } from 'lodash';
import { nativeTokens } from './nativeTokens';
import { geckoChainsMap, geckoTerminalChainsMap } from './constants';
import { ownTokenList } from './ownTokenlist';
import multichainListRawFantom from './multichain/250.json';
import multichainListRawAll from './multichain/anyswap.json';
import { getTokensData } from './getTokensData';
import type { IToken } from './types';
import { zeroAddress } from 'viem';

const tokensToRemove = {
	1: {
		['0xB8c77482e45F1F44dE1745F52C74426C631bDD52'.toLowerCase()]: true
	}
};

const FANTOM_ID = 250;

const oneInchChains = {
	ethereum: 1,
	bsc: 56,
	polygon: 137,
	optimism: 10,
	arbitrum: 42161,
	avax: 43114,
	gnosis: 100,
	fantom: 250,
	//klaytn: 8217,
	base: 8453,
	zksync: 324,
	aurora: 1313161554
};

const fixTotkens = (tokenlist) => {
	// BTC -> BTC.b
	tokenlist[43114].find(
		({ address }) => address.toLowerCase() === '0x152b9d0fdc40c096757f570a51e494bd4b943e50'
	).symbol = 'BTC.b';
	//RSR address
	// tokenlist[1].find(({ address }) => address.toLowerCase() === '0x8762db106b2c2a0bccb3a80d1ed41273552616e8').address =
	// 	'0x320623b8e4ff03373931769a31fc52a4e78b5d70';
	// XDAI -> DAI
	tokenlist[1].find(({ address }) => address.toLowerCase() === '0x6b175474e89094c44da98b954eedeac495271d0f').symbol =
		'DAI';

	return tokenlist;
};

const markMultichain = (tokens) => {
	const multichainTokens = {};
	multichainListRawAll.bridgeList.map((multi) => {
		if (!multichainTokens[multi.chainId]) {
			multichainTokens[multi.chainId] = {};
		}
		multichainTokens[multi.chainId][multi.token?.toLowerCase()] = true;
	});
	Object.values(multichainListRawFantom).map((t) => {
		multichainTokens[FANTOM_ID][t.address?.toLowerCase()] = true;
	});
	Object.entries(tokens).map(([chainId, tokensOnChain]: [string, any[]]) =>
		tokensOnChain.map((token) => {
			if (token.symbol.startsWith('any') || multichainTokens[chainId]?.[token.address.toLowerCase()] === true) {
				token.isMultichain = true;
			}
		})
	);

	return tokens;
};

const allSettled = (promises) =>
	Promise.all(
		promises.map((p) =>
			p
				.then((value) => ({
					status: 'fulfilled',
					value
				}))
				.catch((reason) => ({
					status: 'rejected',
					reason
				}))
		)
	);

const chainsToFetchFromKyberswap = [324, 1101, 59144, 534352, 146];

async function getFullCGTokenlist(){
	const cgCoins = (await fetch("https://api.coingecko.com/api/v3/coins/list?include_platform=true").then(r => r.json())) as {
        "id": string;
        "symbol": string;
        "name": string;
        "platforms": {
            [platform: string]: string
        }
    }[];

    return cgCoins.map(coin => ({
        name: coin.name,
        symbol: coin.symbol,
        platforms: coin.platforms,
    }))
}

export async function getTokenList() {
	// const uniList = await fetch('https://tokens.uniswap.org/').then((r) => r.json());
	// const sushiList = await fetch('https://token-list.sushi.com/').then((r) => r.json());

	const oneInch = await Promise.all(
		Object.values(oneInchChains).map(async (chainId) => {
			for (let i = 0; i < 3; i++) {
				try {
					return await fetch(`https://tokens.1inch.io/v1.1/${chainId}`).then((r) => r.json());
				} catch (e) {}
			}
			throw new Error(`Failed fetching 1inch tokens for chain ${chainId}`);
		})
	);

	const [geckoList, kyberswapLists] = await Promise.all([
		getFullCGTokenlist(),
		await Promise.all(
			chainsToFetchFromKyberswap.map((chainId) =>
				fetch(
					`https://ks-setting.kyberswap.com/api/v1/tokens?page=1&pageSize=100&isWhitelisted=true&chainIds=${chainId}`
				)
					.then((r) => r.json())
					.then((r) => r?.data?.tokens.filter((t) => t.chainId === chainId))
			)
		)
	]);

	const oneInchList = Object.values(oneInchChains)
		.map((chainId, i) =>
			Object.values(oneInch[i]).map((token: { address: string }) => ({
				...token,
				chainId
			}))
		)
		.flat();

	const tokensByChain = mapValues(
		groupBy(
			[...nativeTokens, ...ownTokenList, ...oneInchList, ...kyberswapLists.flat()].filter(
				(t) => t.address !== '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'
			),
			'chainId'
		),
		(val) => uniqBy(val, (token: IToken) => token.address.toLowerCase())
	);

	let tokensFiltered = mapValues(tokensByChain, (val, key) => {
		return val
			.filter((token) => typeof token.address === 'string' && !tokensToRemove[key]?.[token.address.toLowerCase()])
			.map((token) => ({ ...token, address: token.address.toLowerCase() }));
	});

	tokensFiltered = fixTotkens(tokensFiltered);

	tokensFiltered = markMultichain(tokensFiltered);

	// get top tokens on each chain
	const topTokensByChain = await Promise.all(Object.keys(tokensFiltered).map((chain) => getTopTokensByChain(chain)));

	const topTokensByVolume = Object.fromEntries(
		topTokensByChain.filter((chain) => chain !== null && tokensFiltered[chain[0] as string])
	);

	// store unique tokens by chain
	const uniqueTokenList = {};

	for (const chain in tokensFiltered) {
		tokensFiltered[chain].forEach((token) => {
			if (!uniqueTokenList[chain]) {
				uniqueTokenList[chain] = new Set();
			}

			uniqueTokenList[chain].add(token.address.toLowerCase());
		});
	}

	// store coingecko tokens that aren't in above token list by chain
	const geckoListByChain = {};

	if (geckoList && geckoList.length > 0) {
		geckoList.forEach((geckoToken) => {
			Object.entries(geckoToken.platforms || {}).forEach(([chain, address]: [string, string]) => {
				const id = geckoChainsMap[chain];

				if (id && !uniqueTokenList[String(id)]?.has(address.toLowerCase())) {
					if (!geckoListByChain[id]) {
						geckoListByChain[id] = new Set();
					}

					geckoListByChain[id].add(address.toLowerCase());
				}
			});
		});
	}


	// fetch name, symbol, decimals fo coingecko tokens
	const geckoTokensList = (
		await allSettled(
			Object.entries(geckoListByChain).map(([chain, tokens]: [string, Set<string>]) =>
				getTokensData([chain, Array.from(tokens || new Set())])
			)
		)
	).map((t: any) => t.value);
	Object.entries(geckoTokensList).map((v) => {
		if (v[1] === undefined) {
			throw new Error(`Failed getting getTokensData for chain ${Object.entries(geckoListByChain)[v[0]][0]}`);
		}
	});

	const formatAndSortTokens = (tokens, chain) => {
		return tokens
			.map((t) => {
				const volume24h = topTokensByVolume[chain]?.[t.address.toLowerCase()] ?? 0;

				return {
					...t,
					address: t.address.toLowerCase(),
					label: t.symbol,
					value: t.address,
					logoURI: t.ownLogoURI || `https://token-icons.llamao.fi/icons/tokens/${t.chainId}/${t.address}?h=48&w=48`,
					logoURI2: t.logoURI || null,
					volume24h
				};
			})
			.sort((a, b) => (b.address === zeroAddress ? 1 : b.volume24h - a.volume24h));
	};

	// store coingecko token lists by chain
	const cgList = {};
	geckoTokensList.forEach((data) => {
		const [chain, tokens] = data;

		if (!cgList[chain]) {
			cgList[chain] = [];
		}

		cgList[chain] = formatAndSortTokens(tokens || [], chain);
	});

	// format and store final tokens list
	let tokenlist = {};
	for (const chain in { ...tokensFiltered, ...cgList }) {
		tokenlist[chain] = [...formatAndSortTokens(tokensFiltered[chain] || [], chain), ...(cgList[chain] || [])].sort((a,b)=>(b.volume24h ?? 0) - (a.volume24h ?? 0));
	}

	return tokenlist;
}

const getTopTokensByChain = async (chainId: string) => {
	try {
		// Skip if not Ethereum or chain not supported in geckoTerminal
		if (!geckoTerminalChainsMap[chainId]) {
			return [chainId, {}];
		}

		const resData: any[] = [];
		const PAGE_LIMIT = 5;

		// Fetch data from multiple pages in parallel
		const pagePromises = Array.from({ length: PAGE_LIMIT }, (_, i) =>
			fetch(
				`https://pro-api.coingecko.com/api/v3/onchain/networks/${geckoTerminalChainsMap[chainId]}/pools?` +
					'include=dex%2Cdex.network%2Cdex.network.network_metric%2Ctokens&' +
					`page=${i + 1}&include_network_metrics=true`,
				{
					headers: {
						"x-cg-pro-api-key": process.env.CG_API_KEY!
					}
				}
			)
				.then((r) => r.json())
				.catch(() => ({ data: [], included: [] }))
		);

		const responses = await Promise.allSettled(pagePromises);
		responses.forEach((response) => {
			if (response.status === 'fulfilled' && response.value.data) {
				resData.push(...response.value.data);
			} else {
				console.log(geckoTerminalChainsMap[chainId], response)
			}
		});

		const volumeByTokens = {};

		for (const pool of resData) {
			const token = pool.relationships.base_token.data.id.split('_')[1].toLowerCase();
			volumeByTokens[token] = (volumeByTokens[token] || 0) + Number((pool.attributes?.volume_usd?.h24 || '0').split(".")[0]);
		}

		return [chainId, volumeByTokens];
	} catch (error) {
		console.error(`Error fetching top tokens for chain ${chainId}:`, error);
		return [chainId, {}];
	}
};

```

`interface/server/src/tokenlists/getTokensData.ts`:

```ts
import { IToken } from './types';
import { getS3, storeJSONString } from './s3';
import { createPublicClient, erc20Abi } from 'viem';
import { allChains } from '../WalletProvider/chains';
import { rpcsTransports } from '../Aggregator/rpcs';

export const getTokensData = async ([chainId, tokens]: [string, Array<string>]): Promise<[string, Array<IToken>]> => {
	const filename = `erc20/${chainId}`;
	let storedTokenMetadata;
	try {
		storedTokenMetadata = JSON.parse((await getS3(filename)).body!);
	} catch (e) {
		storedTokenMetadata = {};
	}

	const missingTokens = tokens.filter(
		(token) => token !== '' && storedTokenMetadata[token.toLowerCase()] === undefined && token.length === 42
	);

	try {
		const chain = allChains.find((c) => c.id === +chainId);

		if (!chain) {
			throw new Error(`Chain ${chainId} not found`);
		}

		const publicClient = createPublicClient({
			chain,
			transport: rpcsTransports[chainId],
			batch: {
				multicall: {
					wait: 5_000
				}
			}
		});

		const names = await publicClient.multicall({
			contracts: missingTokens.map((token) => ({
				address: token as `0x${string}`,
				abi: erc20Abi,
				functionName: 'name'
			})),
			allowFailure: true
		});

		const symbols = await publicClient.multicall({
			contracts: missingTokens.map((token) => ({
				address: token as `0x${string}`,
				abi: erc20Abi,
				functionName: 'symbol'
			})),
			allowFailure: true
		});

		const decimals = await publicClient.multicall({
			contracts: missingTokens.map((token) => ({
				address: token as `0x${string}`,
				abi: erc20Abi,
				functionName: 'decimals'
			})),
			allowFailure: true
		});

		const data: any[] = [];
		let changed = false;
		missingTokens.forEach((token, i) => {
			const name = names[i];
			const symbol = symbols[i];
			const decimal = decimals[i];

			if (name.status === 'success' && symbol.status === 'success' && decimal.status === 'success') {
				changed = true;
				storedTokenMetadata[token.toLowerCase()] = {
					name: name.result,
					symbol: symbol.result,
					decimals: decimal.result
				};
			}
		});

		tokens.forEach((address) => {
			const info = storedTokenMetadata[address.toLowerCase()];
			if (info) {
				data.push({
					name: info.name,
					symbol: info.symbol,
					decimals: info.decimals,
					address: address,
					chainId,
					geckoId: null,
					logoURI: null,
					isGeckoToken: true
				});
			} else {
				console.log(`[ERROR] [TokensMetaData] ${chainId} ${address} not found`);
			}
		});

		if (changed) {
			await storeJSONString(filename, JSON.stringify(storedTokenMetadata));
		}

		return [chainId, data];
	} catch (error) {
		console.log(`[ERROR] [GetTokensData] ${chainId} ${error}`);
		return [chainId, []];
	}
};

```

`interface/server/src/tokenlists/nativeTokens.ts`:

```ts
import { zeroAddress } from 'viem';

const ICONS_CDN = 'https://icons.llamao.fi/icons';
export function chainIconUrl(chain) {
	return `${ICONS_CDN}/chains/rsz_${chain.toLowerCase()}?w=48&h=48`;
}

const ethereum = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const binance = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 56,
	name: 'Binance',
	symbol: 'BNB',
	logoURI: chainIconUrl('binance'),
	decimals: 18
};

const arbitrum = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 42161,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const optimism = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 10,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const base = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 8453,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const linea = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 59144,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const scroll = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 534352,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const okx = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 66,
	name: 'OKX',
	symbol: 'OKX',
	logoURI: chainIconUrl('okexchain'),
	decimals: 18
};

const boba = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 288,
	logoURI: chainIconUrl('ethereum'),
	name: 'Ethereum',
	symbol: 'ETH',
	decimals: 18
};

const harmony = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1666600000,
	logoURI: chainIconUrl('harmony'),
	decimals: 18,
	name: 'Harmony',
	symbol: 'ONE'
};

const heco = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 128,
	logoURI: chainIconUrl('heco'),
	name: 'Huobi Token',
	symbol: 'HT',
	decimals: 18
};

const velas = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 106,
	logoURI: chainIconUrl('velas'),
	name: 'Velas',
	symbol: 'VLX',
	decimals: 18
};

const oasis = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 24462,
	name: 'Oasis',
	symbol: 'ROSE',
	logoURI: chainIconUrl('oasis'),
	decimals: 18
};

const bttc = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 199,
	name: 'BitTorrent',
	logoURI: chainIconUrl('bittorrent'),
	symbol: 'BTT',
	decimals: 18
};

const moonriver = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1285,
	name: 'MoonRiver',
	logoURI: chainIconUrl('moonriver'),
	symbol: 'MOVR',
	decimals: 18
};

const moonbeam = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1284,
	name: 'Moonbeam',
	logoURI: chainIconUrl('moonbeam'),
	symbol: 'GLMR',
	decimals: 18
};

const fuse = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 122,
	name: 'Fuse',
	logoURI: chainIconUrl('fuse'),
	symbol: 'FUSE',
	decimals: 18
};

const dogechain = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 2000,
	name: 'Doge',
	symbol: 'DOGE',
	decimals: 18,
	logoURI: chainIconUrl('dogechain')
};

const cronos = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 25,
	name: 'Cronos',
	symbol: 'CRO',
	logoURI: chainIconUrl('cronos'),
	decimals: 18
};
const celo = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 42220,
	name: 'Celo',
	symbol: 'CELO',
	logoURI: chainIconUrl('celo'),
	decimals: 18
};
const aurora = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1313161554,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};
const avax = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 43114,
	logoURI: chainIconUrl('avax'),
	name: 'Avalanche',
	symbol: 'AVAX',
	decimals: 18
};

const klaytn = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 8217,
	name: 'Klaytn',
	symbol: 'KLAY',
	logoURI: chainIconUrl('klaytn'),
	decimals: 18
};
const fantom = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 250,
	logoURI: chainIconUrl('fantom'),
	name: 'Fantom',
	symbol: 'FTM',
	decimals: 18
};

const gnosis = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 100,
	name: 'xDai',
	symbol: 'xDai',
	logoURI: chainIconUrl('gnosis'),
	decimals: 18
};
const polygon = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 137,
	name: 'Polygon',
	symbol: 'POL',
	logoURI: chainIconUrl('polygon'),
	decimals: 18
};

const canto = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 7700,
	name: 'Canto',
	symbol: 'CANTO',
	logoURI: chainIconUrl('canto'),
	decimals: 18
};

const metis = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1088,
	name: 'Metis',
	symbol: 'METIS',
	logoURI: chainIconUrl('metis'),
	decimals: 18
};

const polygonzkevm = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1101,
	name: 'Polygon zkEVM',
	symbol: 'ETH',
	logoURI: chainIconUrl('polygon zkevm'),
	decimals: 18
};

const kava = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 2222,
	name: 'Kava',
	symbol: 'KAVA',
	logoURI: chainIconUrl('kava'),
	decimals: 18
};

const zksync = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 324,
	name: 'zkSync Era',
	symbol: 'ETH',
	logoURI: chainIconUrl('zksync era'),
	decimals: 18
};

const ontology = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 58,
	name: 'Ontology',
	symbol: 'ONT',
	logoURI: chainIconUrl('ontologyevm'),
	decimals: 18
};

const pulse = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 369,
	name: 'Pulse',
	symbol: 'PLS',
	logoURI: chainIconUrl('pulse'),
	decimals: 18
};

const sonic = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 146,
	name: 'SONIC',
	symbol: 's',
	logoURI: chainIconUrl('sonic'),
	decimals: 18
};

export const nativeTokens = [
	ethereum,
	arbitrum,
	binance,
	optimism,
	polygon,
	oasis,
	fantom,
	velas,
	harmony,
	gnosis,
	klaytn,
	avax,
	aurora,
	cronos,
	celo,
	dogechain,
	moonriver,
	bttc,
	heco,
	boba,
	okx,
	moonbeam,
	fuse,
	canto,
	metis,
	polygonzkevm,
	kava,
	zksync,
	ontology,
	pulse,
	base,
	linea,
	scroll,
	sonic
];

```

`interface/server/src/tokenlists/ownTokenlist.ts`:

```ts
export const ownTokenList = [
	{
		address: '0x3082CC23568eA640225c2467653dB90e9250AaA0',
		chainId: 42161,
		decimals: 18,
		logoURI:
			'https://raw.githubusercontent.com/sushiswap/list/master/logos/token-logos/network/arbitrum/0x0C4681e6C0235179ec3D4F4fc4DF3d14FDD96017.jpg',
		name: 'Radiant v2',
		symbol: 'RDNT'
	},
	{
		address: '0x0c4681e6c0235179ec3d4f4fc4df3d14fdd96017',
		chainId: 42161,
		decimals: 18,
		logoURI:
			'https://raw.githubusercontent.com/traderjoe-xyz/joe-tokenlists/main/logos/0x0C4681e6C0235179ec3D4F4fc4DF3d14FDD96017/logo.png',
		ownLogoURI:
			'https://raw.githubusercontent.com/traderjoe-xyz/joe-tokenlists/main/logos/0x0C4681e6C0235179ec3D4F4fc4DF3d14FDD96017/logo.png',
		name: 'Radiant OLD',
		symbol: 'RDNT'
	},
	{
		symbol: 'USDC.e',
		chainId: 42161,
		name: 'USD Coin (Bridged)',
		decimals: 6,
		address: '0xff970a61a04b1ca14834a43f5de4533ebddb5cc8',
		logoURI: 'https://tokens.1inch.io/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.png'
	},
	{
		symbol: 'USDC',
		chainId: 42161,
		name: 'USD Coin',
		decimals: 6,
		address: '0xaf88d065e77c8cc2239327c5edb3a432268e5831',
		logoURI: 'https://tokens.1inch.io/0xaf88d065e77c8cc2239327c5edb3a432268e5831.png'
	},
	{
		symbol: 'WWETH',
		chainId: 137,
		name: 'Wormhole WETH',
		decimals: 18,
		address: '0x11cd37bb86f65419713f30673a480ea33c826872',
		logoURI: 'https://token-icons.llamao.fi/icons/tokens/137/0x11cd37bb86f65419713f30673a480ea33c826872?h=20&w=20'
	}
];

```

`interface/server/src/tokenlists/s3.ts`:

```ts
import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectsCommand } from '@aws-sdk/client-s3';

const datasetBucket = 'llama-tokenlists';
const client = new S3Client();

export function storeJSONString(filename: string, body: string, cache?: number) {
	const command = new PutObjectCommand({
		Bucket: datasetBucket,
		Key: filename,
		Body: body,
		ContentType: 'application/json',
		ACL: 'public-read',
		...(!!cache
			? {
					CacheControl: `max-age=${cache}`
			  }
			: {})
	});
	return client.send(command);
}

export async function getS3(filename: string) {
	const command = new GetObjectCommand({
		Bucket: datasetBucket,
		Key: filename
	});
	const data = await client.send(command);
	return {
		body: await data.Body?.transformToString(),
		lastModified: data.LastModified
	};
}

```

`interface/server/src/tokenlists/types.ts`:

```ts
export interface IToken {
	address: string;
	label: string;
	value: string;
	logoURI: string;
	logoURI2?: string | null;
	symbol: string;
	decimals: number;
	name: string;
	chainId: number;
	amount?: string | number;
	balanceUSD?: number;
	geckoId: string | null;
	isGeckoToken?: boolean;
}

```

`interface/server/src/tokenlists/utils.ts`:

```ts
export const normalizeTokens = (t0 = '0', t1 = '0') => {
	if (!t0 || !t1) return null;

	return Number(t0) < Number(t1) ? [t0.toLowerCase(), t1.toLowerCase()] : [t1.toLowerCase(), t0.toLowerCase()];
};

```

`interface/src/components/Aggregator/adapters/0x.ts`:

```ts
import { defillamaReferrerAddress } from '../constants';
import { sendTx } from '../utils/sendTx';
import { zeroAddress } from 'viem';

export const chainToId = {
	ethereum: 'https://api.0x.org/',
	bsc: 'https://bsc.api.0x.org/',
	polygon: 'https://polygon.api.0x.org/',
	optimism: 'https://optimism.api.0x.org/',
	arbitrum: 'https://arbitrum.api.0x.org/',
	avax: 'https://avalanche.api.0x.org/',
	fantom: 'https://fantom.api.0x.org/',
	celo: 'https://celo.api.0x.org/',
	base: 'http://base.api.0x.org/'
};

export const name = 'Matcha/0x';
export const token = 'ZRX';
export const isOutputAvailable = true;

export function approvalAddress() {
	// https://docs.0x.org/0x-api-swap/guides/swap-tokens-with-0x-api
	return '0xdef1c0ded9bec7f1a1670819833240f027b25eff';
}

const nativeToken = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
const feeCollectorAddress = '0x9Ab6164976514F1178E2BB4219DA8700c9D96E9A';

export async function getQuote(chain: string, from: string, to: string, amount: string, extra) {
	// amount should include decimals

	const tokenFrom = from === zeroAddress ? nativeToken : from;
	const tokenTo = to === zeroAddress ? nativeToken : to;
	const amountParam =
		extra.amountOut && extra.amountOut !== '0' ? `buyAmount=${extra.amountOut}` : `sellAmount=${amount}`;

	const data = await fetch(
		`${chainToId[chain]}swap/v1/quote?buyToken=${tokenTo}&${amountParam}&sellToken=${tokenFrom}&slippagePercentage=${
			extra.slippage / 100
		}&affiliateAddress=${defillamaReferrerAddress}&enableSlippageProtection=false&intentOnFilling=true&takerAddress=${
			extra.userAddress
		}&skipValidation=true&feeRecipientTradeSurplus=${feeCollectorAddress}`,
		{
			headers: {
				'0x-api-key': process.env.OX_API_KEY as string
			}
		}
	).then((r) => r.json());

	return {
		amountReturned: data?.buyAmount || 0,
		amountIn: data?.sellAmount || 0,
		estimatedGas: data.gas,
		tokenApprovalAddress: data.to,
		rawQuote: data,
		logo: 'https://www.gitbook.com/cdn-cgi/image/width=40,height=40,fit=contain,dpr=2,format=auto/https%3A%2F%2F1690203644-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FKX9pG8rH3DbKDOvV7di7%252Ficon%252F1nKfBhLbPxd2KuXchHET%252F0x%2520logo.png%3Falt%3Dmedia%26token%3D25a85a3e-7f72-47ea-a8b2-e28c0d24074b'
	};
}

export async function swap({ fromAddress, rawQuote, chain }) {
	const tx = await sendTx({
		from: fromAddress,
		to: rawQuote.to,
		data: rawQuote.data,
		value: rawQuote.value,
	});

	return tx;
}

export const getTxData = ({ rawQuote }) => rawQuote?.data;

export const getTx = ({ rawQuote }) => ({
	to: rawQuote.to,
	data: rawQuote.data,
	value: rawQuote.value
});

```

`interface/src/components/Aggregator/adapters/0xGasless.ts`:

```ts
import { defillamaReferrerAddress, tokenApprovalAbi } from '../constants';
import { decodeFunctionData, encodeFunctionData, getAddress, hexToNumber, parseSignature, zeroAddress } from 'viem';
import { signTypedData } from 'wagmi/actions';
import { config } from '../../WalletProvider';

export const chainToId = {
	ethereum: '1',
	polygon: '137',
	optimism: '10',
	arbitrum: '42161',
	base: '8453'
};

export const name = '0x Gasless';
export const token = 'ZRX';

const nativeToken = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
const feeCollectorAddress = '0x9Ab6164976514F1178E2BB4219DA8700c9D96E9A';

export const isGasless = true;

export const isOutputAvailable = true;

const routers = {
	ethereum: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',
	arbitrum: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',
	optimism: '0xdef1abe32c034e558cdd535791643c58a13acc10',
	base: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',
	polygon: '0xdef1c0ded9bec7f1a1670819833240f027b25eff'
};

export async function getQuote(chain: string, from: string, to: string, amount: string, extra) {
	// amount should include decimals

	const tokenFrom = from === zeroAddress ? nativeToken : from;
	const tokenTo = to === zeroAddress ? nativeToken : to;
	const amountParam =
		extra.amountOut && extra.amountOut !== '0' ? `buyAmount=${extra.amountOut}` : `sellAmount=${amount}`;

	const data = await fetch(
		`https://api.0x.org/tx-relay/v1/swap/quote?buyToken=${tokenTo}&${amountParam}&sellToken=${tokenFrom}&checkApproval=true&slippagePercentage=${
			extra.slippage / 100
		}&affiliateAddress=${defillamaReferrerAddress}&takerAddress=${
			extra.userAddress
		}&feeRecipient=${feeCollectorAddress}&feeSellTokenPercentage=0.0015`,
		{
			headers: {
				'0x-api-key': process.env.OX_API_KEY as string,
				'0x-chain-id': chainToId[chain]
			}
		}
	).then((r) => r.json());

	// do not show quote if there's not enough liquidity
	if (!data.liquidityAvailable) return null;

	// hide quote if it's unknown gasless approval signature
	if (data.approval.isRequired && data.approval.isGaslessAvailable) {
		if (!['Permit'].includes(data.approval.eip712.primaryType)) {
			return null;
		}

		let spender;

		if (data.approval.eip712.primaryType === 'Permit') {
			spender = data.approval.eip712.message.spender;
		}

		if (data.approval.eip712.primaryType === 'MetaTransaction') {
			spender = decodeFunctionData({
				abi: tokenApprovalAbi,
				data: data.approval.eip712.message.functionSignature
			}).args[0];
		}

		if (!spender || spender.toLowerCase() !== routers[chain].toLowerCase()) {
			throw new Error(`Router address does not match`);
		}
	}

	if (
		data.allowanceTarget.toLowerCase() !== routers[chain].toLowerCase() ||
		data.trade.eip712.domain.verifyingContract.toLowerCase() !== routers[chain].toLowerCase()
	) {
		throw new Error(`Router address does not match`);
	}

	const isGaslessApproval = data.approval.isRequired && data.approval.isGaslessAvailable ? true : false;

	return {
		amountReturned: data.buyAmount,
		amountIn: data.sellAmount,
		rawQuote: data,
		estimatedGas: 0, // Currently swaps from ETH are not supported, so we don't handle gas costs for them
		tokenApprovalAddress: data.allowanceTarget ?? null,
		isGaslessApproval,
		isMEVSafe: true,
		logo: 'https://www.gitbook.com/cdn-cgi/image/width=40,height=40,fit=contain,dpr=2,format=auto/https%3A%2F%2F1690203644-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FKX9pG8rH3DbKDOvV7di7%252Ficon%252F1nKfBhLbPxd2KuXchHET%252F0x%2520logo.png%3Falt%3Dmedia%26token%3D25a85a3e-7f72-47ea-a8b2-e28c0d24074b'
	};
}

export async function gaslessApprove({ rawQuote, isInfiniteApproval }) {
	const body: any = {};

	if (rawQuote.approval.isRequired && rawQuote.approval.isGaslessAvailable) {
		const message = isInfiniteApproval
			? rawQuote.approval.eip712.message
			: rawQuote.approval.eip712.primaryType === 'Permit'
				? {
						...rawQuote.approval.eip712.message,
						value: rawQuote.sellAmount
					}
				: rawQuote.approval.eip712.primaryType === 'MetaTransaction'
					? {
							...rawQuote.approval.eip712.message,
							functionSignature: encodeFunctionData({
								abi: tokenApprovalAbi,
								functionName: 'approve',
								args: [getAddress(rawQuote.allowanceTarget), rawQuote.sellAmount]
							})
						}
					: null;

		const approvalSignature = await signTypedData(config, {
			domain: rawQuote.approval.eip712.domain,
			types: rawQuote.approval.eip712.types,
			primaryType: rawQuote.approval.eip712.primaryType,
			message
		}).then((hash) => {
			const { r, s } = parseSignature(hash);
			return { v: hexToNumber(`0x${hash.slice(130)}`), r, s };
		});

		body.approval = {
			type: rawQuote.approval.type,
			eip712: { ...rawQuote.approval.eip712, message },
			signature: padSignature({
				v: approvalSignature.v,
				r: approvalSignature.r,
				s: approvalSignature.s,
				recoveryParam: 1 - (approvalSignature.v % 2),
				signatureType: 2
			})
		};
	}

	return body;
}

// https://github.com/0xProject/0x-examples/blob/main/gasless-v2-headless-example/utils/signature.ts
/**
 * Sometimes signatures are split without leading bytes on the `r` and/or `s` fields.
 *
 * Add them if they don't exist.
 */
function padSignature(signature) {
	const hexLength = 64;

	const result = { ...signature };

	const hexExtractor = /^0(x|X)(?<hex>\w+)$/;
	const rMatch = signature.r.match(hexExtractor);
	const rHex = rMatch?.groups?.hex;
	if (rHex) {
		if (rHex.length !== hexLength) {
			result.r = `0x${rHex.padStart(hexLength, '0')}`;
		}
	}

	const sMatch = signature.s.match(hexExtractor);
	const sHex = sMatch?.groups?.hex;
	if (sHex) {
		if (sHex.length !== hexLength) {
			result.s = `0x${sHex.padStart(hexLength, '0')}`;
		}
	}
	return result;
}

export async function swap({ rawQuote, chain, approvalData }) {
	const body = { ...(rawQuote.approval.isRequired && rawQuote.approval.isGaslessAvailable ? approvalData ?? {} : {}) };

	const tradeSignature = await signTypedData(config, {
		domain: rawQuote.trade.eip712.domain,
		types: rawQuote.trade.eip712.types,
		primaryType: rawQuote.trade.eip712.primaryType,
		message: rawQuote.trade.eip712.message
	}).then((hash) => {
		const { r, s } = parseSignature(hash);
		return { v: hexToNumber(`0x${hash.slice(130)}`), r, s };
	});

	body.trade = {
		type: rawQuote.trade.type,
		eip712: rawQuote.trade.eip712,
		signature: padSignature({
			v: tradeSignature.v,
			r: tradeSignature.r,
			s: tradeSignature.s,
			recoveryParam: 1 - (tradeSignature.v % 2),
			signatureType: 2
		})
	};

	const res = await fetch(
		`https://swap-api.defillama.com/submitSwap?protocol=${encodeURIComponent(
			name
		)}&chain=${chain}&api_key=nsr_UYWxuvj1hOCgHxJhDEKZ0g30c4Be3I5fOMBtFAA`,
		{
			method: 'POST',
			body: JSON.stringify(body)
		}
	).then((res) => res.json());
	return res;
}

export async function submitSwap({ chain, body }) {
	const tx = await fetch(`https://api.0x.org/tx-relay/v1/swap/submit`, {
		headers: {
			'0x-api-key': process.env.OX_API_KEY as string,
			'0x-chain-id': chainToId[chain],
			'Content-Type': 'application/json'
		},
		method: 'POST',
		body: JSON.stringify(body)
	})
		.then((r) => r.json())
		.catch((err) => {
			console.log({ err });
		});

	if (!tx.tradeHash) {
		return {
			gaslessTxReceipt: {
				status: 'failed',
				reason: tx.validationErrors
					? tx.validationErrors.map((t) => t.reason).join(', ')
					: tx.reason ?? 'Something went wrong'
			}
		};
	}

	let gaslessTxReceipt;
	let runs = 0;
	do {
		runs += 1;

		gaslessTxReceipt = await fetch(`https://api.0x.org/tx-relay/v1/swap/status/${tx.tradeHash}`, {
			headers: {
				'0x-api-key': process.env.OX_API_KEY as string,
				'0x-chain-id': chainToId[chain]
			}
		}).then((res) => res.json());

		if (gaslessTxReceipt.status !== 'pending') {
			return { gaslessTxReceipt };
		} else {
			// sleep for 5 seconds
			await sleep(5_000);
		}
	} while (gaslessTxReceipt.status === 'pending' && runs < 12); // keep querying status upto a min

	return { gaslessTxReceipt };
}

const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

```

`interface/src/components/Aggregator/adapters/0xV2.ts`:

```ts
import { numberToHex, size, zeroAddress, concat} from 'viem';
import { sendTx } from '../utils/sendTx';

export const name = 'Matcha/0x v2';
export const token = 'ZRX';
export const isOutputAvailable = false;

export const chainToId = {
	ethereum: '1',
	bsc: '56',
	polygon: '137',
	optimism: '10',
	arbitrum: '42161',
	avax: '43114',
	base: '8453',
	linea: '59144',
	scroll: '534352',
	blast: '81457',
	mantle: '5000',
	mode: '34443'
	// missing unichain
};

const nativeToken = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
const feeCollectorAddress = '0x9Ab6164976514F1178E2BB4219DA8700c9D96E9A';
const permit2Address = '0x000000000022d473030f116ddee9f6b43ac78ba3';

export async function getQuote(chain: string, from: string, to: string, amount: string, extra) {
	// amount should include decimals

	const tokenFrom = from === zeroAddress ? nativeToken : from;
	const tokenTo = to === zeroAddress ? nativeToken : to;

	if (extra.amountOut && extra.amountOut !== '0') {
		throw new Error('Invalid query params');
	}

	const amountParam = `sellAmount=${amount}`;

	const taker = extra.userAddress === zeroAddress ? '0x1000000000000000000000000000000000000000' : extra.userAddress;

	// only expects integer
	const slippage = (extra.slippage * 100) | 0;

	const data = await fetch(
		`https://api.0x.org/swap/permit2/quote?chainId=${chainToId[chain]}&buyToken=${tokenTo}&${amountParam}&sellToken=${tokenFrom}&slippageBps=${slippage}&taker=${taker}&tradeSurplusRecipient=${feeCollectorAddress}`,
		{
			headers: {
				'0x-api-key': process.env.OX_API_KEY as string,
				'0x-version': 'v2'
			}
		}
	).then(async (r) => {
		if (r.status !== 200) {
			throw new Error('Failed to fetch');
		}

		const data = await r.json();

		return data;
	});

	if (
		data.permit2 !== null &&
		data.permit2.eip712.domain.verifyingContract.toLowerCase() !== permit2Address.toLowerCase()
	) {
		throw new Error(`Approval address does not match`);
	}

	return {
		amountReturned: data?.buyAmount || 0,
		amountIn: data?.sellAmount || 0,
		tokenApprovalAddress: permit2Address,
		estimatedGas: data.transaction.gas,
		rawQuote: { ...data, gasLimit: data.transaction.gas },
		isSignatureNeededForSwap: true,
		logo: 'https://www.gitbook.com/cdn-cgi/image/width=40,height=40,fit=contain,dpr=2,format=auto/https%3A%2F%2F1690203644-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FKX9pG8rH3DbKDOvV7di7%252Ficon%252F1nKfBhLbPxd2KuXchHET%252F0x%2520logo.png%3Falt%3Dmedia%26token%3D25a85a3e-7f72-47ea-a8b2-e28c0d24074b'
	};
}

export async function signatureForSwap({ rawQuote, signTypedDataAsync }) {
	const signature = await signTypedDataAsync(rawQuote.permit2.eip712).catch((err) => {
		console.log(err)
	});
	return signature;
}

export async function swap({ fromAddress, rawQuote, signature }) {
	// signature not needed if using allowance holder api
	const signatureLengthInHex = signature
		? numberToHex(size(signature), {
				signed: false,
				size: 32
			})
		: null;
	const data = signature
		? concat([rawQuote.transaction.data, signatureLengthInHex, signature])
		: rawQuote.transaction.data;
	const tx = await sendTx({
		from: fromAddress,
		to: rawQuote.transaction.to,
		data,
		value: rawQuote.transaction.value
	});

	return tx;
}

export const getTxData = ({ rawQuote }) => rawQuote?.transaction?.data;

export const getTx = ({ rawQuote }) => ({
	to: rawQuote.transaction.to,
	data: rawQuote.transaction.data,
	value: rawQuote.transaction.value
});

```

`interface/src/components/Aggregator/adapters/1inch.test.ts`:

```ts
import { approvalAddress, chainToId } from './1inch';
import fetch from 'node-fetch';

export async function testApprovalAddresses() {
	await Promise.all(
		Object.keys(chainToId).map(async (chain) => {
			const { address: tokenApprovalAddress } = await fetch(
				`https://api.1inch.dev/swap/v6.0/${chainToId[chain]}/approve/spender`,
				{
					headers: { 'Authorization': "Bearer " + process.env.INCH_API_KEY! }
				}
			).then((r) => r.json());
			if (tokenApprovalAddress !== approvalAddress(chain)) {
				console.log(`Address for ${chain} is wrong`);
			}
		})
	);
}
testApprovalAddresses();

```

`interface/src/components/Aggregator/adapters/1inch.ts`:

```ts
// Source https://portal.1inch.dev/documentation/apis/swap/classic-swap/introduction

import { altReferralAddress } from '../constants';
import { sendTx } from '../utils/sendTx';
import { estimateGas } from 'wagmi/actions';
import { config } from '../../WalletProvider';
import { zeroAddress } from 'viem';

export const chainToId = {
	ethereum: 1,
	bsc: 56,
	polygon: 137,
	optimism: 10,
	arbitrum: 42161,
	gnosis: 100,
	avax: 43114,
	fantom: 250,
	klaytn: 8217,
	aurora: 1313161554,
	zksync: 324,
	base: 8453
};

const spenders = {
	ethereum: '0x111111125421ca6dc452d289314280a0f8842a65',
	bsc: '0x111111125421ca6dc452d289314280a0f8842a65',
	polygon: '0x111111125421ca6dc452d289314280a0f8842a65',
	optimism: '0x111111125421ca6dc452d289314280a0f8842a65',
	arbitrum: '0x111111125421ca6dc452d289314280a0f8842a65',
	gnosis: '0x111111125421ca6dc452d289314280a0f8842a65',
	avax: '0x111111125421ca6dc452d289314280a0f8842a65',
	fantom: '0x111111125421ca6dc452d289314280a0f8842a65',
	klaytn: '0x111111125421ca6dc452d289314280a0f8842a65',
	aurora: '0x111111125421ca6dc452d289314280a0f8842a65',
	zksync: '0x6fd4383cb451173d5f9304f041c7bcbf27d561ff',
	base: '0x111111125421ca6dc452d289314280a0f8842a65'
};

export const name = '1inch';
export const token = '1INCH';
export const referral = true;

export function approvalAddress(chain: string) {
	// https://api.1inch.io/v6.0/1/approve/spender
	return spenders[chain];
}
const nativeToken = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';

const apiEndpoint = 'https://api.1inch.dev/swap/v6.0/';

export async function getQuote(chain: string, from: string, to: string, amount: string, extra) {
	// ethereum = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE
	// amount should include decimals

	const tokenFrom = from === zeroAddress ? nativeToken : from;
	const tokenTo = to === zeroAddress ? nativeToken : to;
	const authHeader = process.env.INCH_API_KEY ? { 'Authorization': `Bearer ${process.env.INCH_API_KEY as string}` } : {};
	const tokenApprovalAddress = spenders[chain];

	const [data, swapData] = await Promise.all([
		fetch(
			`${apiEndpoint}${chainToId[chain]}/quote?src=${tokenFrom}&dst=${tokenTo}&amount=${amount}&includeGas=true`,
			{ headers: authHeader as any }
		).then((r) => r.json()),
		extra.userAddress !== zeroAddress
			? fetch(
				`${apiEndpoint}${chainToId[chain]}/swap?src=${tokenFrom}&dst=${tokenTo}&amount=${amount}&from=${extra.userAddress}&origin=${extra.userAddress}&slippage=${extra.slippage}&referrer=${altReferralAddress}&disableEstimate=true`,
				{ headers: authHeader as any }
			).then((r) => r.json())
			: null
	]);

	if(swapData && swapData.tx.to.toLowerCase() !== tokenApprovalAddress.toLowerCase()){
		throw new Error("approval address doesn't match")
	}

	const estimatedGas = data.gas || 0;

	let gas = estimatedGas;

	return {
		amountReturned: swapData?.dstAmount ?? data.dstAmount,
		estimatedGas: gas,
		tokenApprovalAddress,
		rawQuote: swapData === null ? null : { ...swapData, tx: swapData.tx },
		logo: 'https://icons.llamao.fi/icons/protocols/1inch-network?w=48&q=75'
	};
}

export async function swap({ rawQuote }) {
	const txObject = {
		from: rawQuote.tx.from,
		to: rawQuote.tx.to,
		data: rawQuote.tx.data,
		value: rawQuote.tx.value
	};

	const gasPrediction = await estimateGas(config, txObject).catch(() => null);

	const tx = await sendTx({
		...txObject,
		// Increase gas +20% + 2 erc20 txs
		...(gasPrediction ? { gas: (gasPrediction * 12n) / 10n + 86000n } : {})
	});
	return tx;
}

export const getTxData = ({ rawQuote }) => rawQuote?.tx?.data;

export const getTx = ({ rawQuote }) => {
	if (rawQuote === null) {
		return {};
	}
	return {
		from: rawQuote.tx.from,
		to: rawQuote.tx.to,
		data: rawQuote.tx.data,
		value: rawQuote.tx.value
	};
};

```

`interface/src/components/Aggregator/adapters/airswap.ts`:

```ts
import { readContract } from 'wagmi/actions';
import { config } from '../../WalletProvider';
import { chainsMap } from '../constants';

// https://about.airswap.io/technology/protocols

// registry addresses
export const chainToId = {
	ethereum: '0x8F9DA6d38939411340b19401E8c54Ea1f51B8f95',
	bsc: '0x9F11691FA842856E44586380b27Ac331ab7De93d',
	polygon: '0x9F11691FA842856E44586380b27Ac331ab7De93d',
	avax: '0xE40feb39fcb941A633deC965Abc9921b3FE962b2'
};

const swapContracts = {
	ethereum: '0x522D6F36c95A1b6509A14272C17747BbB582F2A6',
	bsc: '0x132F13C3896eAB218762B9e46F55C9c478905849',
	polygon: '0x6713C23261c8A9B7D84Dd6114E78d9a7B9863C1a',
	avax: '0xEc08261ac8b3D2164d236bD499def9f82ba9d13F'
};

export const name = 'AirSwap';
export const token = 'AST';

// https://about.airswap.io/technology/deployments
export function approvalAddress(chain: string) {
	return swapContracts[chain];
}

export async function getQuote(chain: string, from: string, to: string, amount: string) {
	const [fromServers, toServers] = await Promise.all(
		[from, to].map((t) =>
			readContract(config, {
				address: chainToId[chain],
				abi: [
					{
						inputs: [{ internalType: 'address', name: 'token', type: 'address' }],
						name: 'getURLsForToken',
						outputs: [{ internalType: 'string[]', name: 'urls', type: 'string[]' }],
						stateMutability: 'view',
						type: 'function'
					}
				],
				functionName: 'getURLsForToken',
				args: [t as `0x${string}`],
				chainId: chainsMap[chain]
			})
		)
	);

	const overlappingServers = fromServers.filter((s) => toServers.includes(s));

	const controller = new AbortController();

	const offers = (
		await Promise.all(
			overlappingServers.map((s) =>
				fetch(s, {
					method: 'POST',
					body: JSON.stringify({
						jsonrpc: '2.0',
						id: '78e032d0-2894-42fd-99ce-22dfd14cf65b',
						method: 'getSignerSideOrder', // getSignerSideOrder -> provide input amount, getSenderSideOrder -> provide output amount
						params: {
							signerToken: to,
							senderWallet: '0x3a0e257568cc9c6c5d767d5dc0cd8a9ac69cc3ae', // wrapper contract
							senderToken: from,
							senderAmount: amount,
							swapContract: swapContracts[chain]
						}
					}),
					signal: controller.signal,
					headers: {
						'Content-Type': 'application/json'
					}
				})
					.then((r) => r.json())
					.then((r) => (r.error === undefined ? r.result : null))
					.catch((e) => null)
			)
		)
	).filter((r) => r !== null) as any[];
	const bestOffer = offers.reduce((min, offer) => offer.signerAmount > min.signerAmount);
	return {
		amountReturned: bestOffer.signerAmount,
		estimatedGas: 200885, // based on a previous tx, needs fixing
		validTo: bestOffer.expiry,
		rawQuote: bestOffer
	};
}

```

`interface/src/components/Aggregator/adapters/cowswap/abi.ts`:

```ts
export const ABI = {
	nativeSwap: [
		{
			inputs: [
				{
					components: [
						{ internalType: 'contract IERC20', name: 'buyToken', type: 'address' },
						{ internalType: 'address', name: 'receiver', type: 'address' },
						{ internalType: 'uint256', name: 'sellAmount', type: 'uint256' },
						{ internalType: 'uint256', name: 'buyAmount', type: 'uint256' },
						{ internalType: 'bytes32', name: 'appData', type: 'bytes32' },
						{ internalType: 'uint256', name: 'feeAmount', type: 'uint256' },
						{ internalType: 'uint32', name: 'validTo', type: 'uint32' },
						{ internalType: 'bool', name: 'partiallyFillable', type: 'bool' },
						{ internalType: 'int64', name: 'quoteId', type: 'int64' }
					],
					internalType: 'struct EthFlowOrder.Data',
					name: 'order',
					type: 'tuple'
				}
			],
			name: 'createOrder',
			outputs: [{ internalType: 'bytes32', name: 'orderHash', type: 'bytes32' }],
			stateMutability: 'payable',
			type: 'function'
		}
	],
	settlement: [
		{
			anonymous: false,
			inputs: [{ indexed: true, internalType: 'address', name: 'solver', type: 'address' }],
			name: 'Settlement',
			type: 'event'
		},
		{
			anonymous: false,
			inputs: [
				{ indexed: true, internalType: 'address', name: 'owner', type: 'address' },
				{ indexed: false, internalType: 'contract IERC20', name: 'sellToken', type: 'address' },
				{ indexed: false, internalType: 'contract IERC20', name: 'buyToken', type: 'address' },
				{ indexed: false, internalType: 'uint256', name: 'sellAmount', type: 'uint256' },
				{ indexed: false, internalType: 'uint256', name: 'buyAmount', type: 'uint256' },
				{ indexed: false, internalType: 'uint256', name: 'feeAmount', type: 'uint256' },
				{ indexed: false, internalType: 'bytes', name: 'orderUid', type: 'bytes' }
			],
			name: 'Trade',
			type: 'event'
		}
	]
};

```

`interface/src/components/Aggregator/adapters/cowswap/index.ts`:

```ts
// Source: https://docs.cow.fi/off-chain-services/api

import { ExtraData } from '../../types';

import BigNumber from 'bignumber.js';
import { zeroAddress } from 'viem';
import { signTypedData, watchContractEvent, writeContract } from 'wagmi/actions';
import { config } from '../../../WalletProvider';
import { chainsMap } from '../../constants';
import { ABI } from './abi';

export const chainToId = {
	ethereum: 'https://api.cow.fi/mainnet',
	gnosis: 'https://api.cow.fi/xdai',
	arbitrum: 'https://api.cow.fi/arbitrum_one',
	base: 'https://api.cow.fi/base'
};

export const cowSwapEthFlowSlippagePerChain = {
	ethereum: 2,
	gnosis: 0.5,
	arbitrum: 0.5,
	base: 0.5
};

const wrappedTokens = {
	ethereum: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
	gnosis: '0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d',
	arbitrum: '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1',
	base: '0x4200000000000000000000000000000000000006'
};

const cowContractAddress = '0xC92E8bdf79f0507f65a392b0ab4667716BFE0110';
const cowSwapEthFlowContractAddress = '0xba3cb449bd2b4adddbc894d8697f5170800eadec';

const nativeSwapAddress = {
	ethereum: cowSwapEthFlowContractAddress,
	gnosis: cowSwapEthFlowContractAddress,
	arbitrum: cowSwapEthFlowContractAddress,
	base: cowSwapEthFlowContractAddress
};

export const name = 'CowSwap';
export const token = 'COW';
export const referral = true;
export const isOutputAvailable = true;

export function approvalAddress() {
	return cowContractAddress;
}
const nativeToken = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';

const feeRecipientAddress = '0x1713B79e3dbb8A76D80e038CA701A4a781AC69eB';

function buildAppData(slippage: string) {
	// Convert slippage to basis points
	const bps = Math.round(Number(slippage) * 100);
	// Must be an integer between 0 and 10000
	const slippageBips = isNaN(bps) || bps < 0 || bps > 10000 ? undefined : bps;

	return JSON.stringify({
		version: '1.4.0',
		appCode: 'DefiLlama',
		environment: 'production',
		metadata: {
			orderClass: {
				orderClass: 'market'
			},
			partnerFee: {
				priceImprovementBps: 9900, // Capture 99% of the price improvement
				maxVolumeBps: 100, // Capped at 1% volume
				recipient: feeRecipientAddress
			},
			// Include slippage in the appData if there's a valid value provided
			...(slippageBips ? { quote: { slippageBips } } : undefined)
		}
	});
}

const waitForOrder =
	({ uid, trader, chain }) =>
	(onSuccess) => {
		const unwatch = watchContractEvent(config, {
			address: '0x9008D19f58AAbD9eD0D60971565AA8510560ab41',
			abi: ABI.settlement,
			eventName: 'Trade',
			args: { owner: trader },
			chainId: chainsMap[chain],
			onLogs(logs) {
				const trade = logs.find((log) => log.data.includes(uid.substring(2)));
				if (trade) {
					onSuccess();
					unwatch();
				}
			},
			onError(error) {
				console.log('Error confirming order status', error);
				unwatch();
			}
		});
	};

// https://docs.cow.fi/tutorials/how-to-submit-orders-via-the-api/2.-query-the-fee-endpoint
export async function getQuote(chain: string, from: string, to: string, amount: string, extra: ExtraData) {
	const isEthflowOrder = from === zeroAddress;
	const tokenTo = to === zeroAddress ? nativeToken : to;
	const tokenFrom = isEthflowOrder ? wrappedTokens[chain] : from;
	const isBuyOrder = extra.amountOut && extra.amountOut !== '0';

	// Ethflow orders are always sell orders.
	// Source: https://github.com/cowprotocol/ethflowcontract/blob/v1.0.0/src/libraries/EthFlowOrder.sol#L93-L95
	if (isEthflowOrder && isBuyOrder) {
		throw new Error('buy orders from Ether are not allowed');
	}

	// amount should include decimals
	const data = await fetch(`${chainToId[chain]}/api/v1/quote`, {
		method: 'POST',
		body: JSON.stringify({
			sellToken: tokenFrom,
			buyToken: tokenTo,
			receiver: extra.userAddress,
			// Caveat: slippage is only updated in the appData when a new quote is fetched
			appData: buildAppData(extra.slippage),
			partiallyFillable: false,
			sellTokenBalance: 'erc20',
			buyTokenBalance: 'erc20',
			from: extra.userAddress,
			//"priceQuality": "fast",
			signingScheme: isEthflowOrder ? 'eip1271' : 'eip712', // for selling directly ether, another signature type is required
			onchainOrder: isEthflowOrder ? true : false, // for selling directly ether, we have to quote for onchain orders
			kind: isBuyOrder ? 'buy' : 'sell',
			...(isBuyOrder ? { buyAmountAfterFee: extra.amountOut } : { sellAmountBeforeFee: amount })
		}),
		headers: {
			'Content-Type': 'application/json'
		}
	}).then((r) => r.json());
	// These orders should never be sent, but if they ever are signed they could be used to drain account
	// Source: https://docs.cow.fi/tutorials/how-to-submit-orders-via-the-api/4.-signing-the-order
	if (data.quote.sellAmount === 0 && data.quote.buyAmount === 0 && data.quote.partiallyFillable === false) {
		throw new Error('Buggy quote from cowswap');
	}

	const expectedBuyAmount = data.quote.buyAmount;
	const expectedSellAmount = BigNumber(data?.quote.sellAmount).plus(data.quote.feeAmount).toFixed(0);
	if (isBuyOrder) {
		data.quote.sellAmount = BigNumber(data.quote.sellAmount)
			.times(1 + Number(extra.slippage) / 100)
			.toFixed(0);
	} else {
		data.quote.buyAmount = BigNumber(expectedBuyAmount)
			.times(1 - Number(extra.slippage) / 100)
			.toFixed(0);
	}

	return {
		amountReturned: expectedBuyAmount,
		amountIn: expectedSellAmount || '0',
		estimatedGas: isEthflowOrder ? 56360 : 0, // 56360 is gas from sending createOrder() tx
		validTo: data.quote?.validTo || 0,
		rawQuote: { ...data, slippage: extra.slippage },
		tokenApprovalAddress: cowContractAddress,
		logo: 'https://raw.githubusercontent.com/cowprotocol/token-lists/refs/heads/main/src/public/images/1/0xdef1ca1fb7fbcdc777520aa7f396b4e015f497ab/logo.png',
		isMEVSafe: true
	};
}

export async function swap({ chain, fromAddress, rawQuote, from, to }) {

	if (from === zeroAddress) {
		const minEthFlowSlippage = cowSwapEthFlowSlippagePerChain[chain];
		if (rawQuote.slippage < minEthFlowSlippage) {
			throw { reason: `Slippage for ETH orders on CoW Swap needs to be higher than ${minEthFlowSlippage}%` };
		}

		// Upload appData as it's not included in the order for ethflow orders
		const uploadedAppDataHash = await fetch(`${chainToId[chain]}/api/v1/app_data/${rawQuote.quote.appDataHash}`, {
			method: 'PUT',
			body: JSON.stringify({ fullAppData: rawQuote.quote.appData }),
			headers: {
				'Content-Type': 'application/json'
			}
		}).then((r) => r.json());

		if (uploadedAppDataHash !== rawQuote.quote.appDataHash) {
			// AppDataHash differs, it means the body is different. Do not proceed
			// Unlikely to happen, but leaving the check in place just in case
			throw { reason: 'Failed to place order, please try again' };
		}

		// Only if the upload was successful, we can proceed with the order
		try {
			const tx = await writeContract(config, {
				address: nativeSwapAddress[chain],
				abi: ABI.nativeSwap,
				functionName: 'createOrder',
				args: [
					{
						buyToken: to as `0x${string}`,
						receiver: fromAddress as `0x${string}`,
						sellAmount: BigInt(rawQuote.quote.sellAmount) + BigInt(rawQuote.quote.feeAmount),
						buyAmount: BigInt(rawQuote.quote.buyAmount),
						appData: rawQuote.quote.appDataHash,
						feeAmount: 0n,
						validTo: rawQuote.quote.validTo,
						partiallyFillable: rawQuote.quote.partiallyFillable,
						quoteId: rawQuote.id
					}
				],
				value: BigInt(rawQuote.quote.sellAmount) + BigInt(rawQuote.quote.feeAmount)
			});

			return tx;
		} catch (error) {
			// Handle failures, such as user rejecting the transaction
			console.warn('Error creating CoW Swap ethFlow order', error);
			throw { reason: 'Failed to place order, please try again' };
		}
	} else {
		// https://docs.cow.fi/cow-protocol/reference/core/signing-schemes#javascript-example
		const order = {
			sellToken: rawQuote.quote.sellToken as `0x${string}`,
			buyToken: rawQuote.quote.buyToken as `0x${string}`,
			receiver: fromAddress as `0x${string}`,
			sellAmount: BigInt(rawQuote.quote.sellAmount) + BigInt(rawQuote.quote.feeAmount),
			buyAmount: BigInt(rawQuote.quote.buyAmount),
			validTo: rawQuote.quote.validTo as number,
			appData: rawQuote.quote.appDataHash,
			feeAmount: 0n,
			kind: rawQuote.quote.kind as string,
			partiallyFillable: rawQuote.quote.partiallyFillable as boolean,
			sellTokenBalance: 'erc20',
			buyTokenBalance: 'erc20'
		};

		const signature = await signTypedData(config, {
			primaryType: 'Order',
			message: order,
			domain: {
				name: 'Gnosis Protocol',
				version: 'v2',
				chainId: chainsMap[chain],
				verifyingContract: '0x9008D19f58AAbD9eD0D60971565AA8510560ab41'
			},
			types: {
				Order: [
					{ name: 'sellToken', type: 'address' },
					{ name: 'buyToken', type: 'address' },
					{ name: 'receiver', type: 'address' },
					{ name: 'sellAmount', type: 'uint256' },
					{ name: 'buyAmount', type: 'uint256' },
					{ name: 'validTo', type: 'uint32' },
					{ name: 'appData', type: 'bytes32' },
					{ name: 'feeAmount', type: 'uint256' },
					{ name: 'kind', type: 'string' },
					{ name: 'partiallyFillable', type: 'bool' },
					{ name: 'sellTokenBalance', type: 'string' },
					{ name: 'buyTokenBalance', type: 'string' }
				]
			}
		});

		const data = await fetch(`${chainToId[chain]}/api/v1/orders`, {
			method: 'POST',
			body: JSON.stringify({
				...rawQuote.quote,
				sellAmount: String(order.sellAmount),
				feeAmount: '0',
				signature,
				signingScheme: 'eip712'
			}),
			headers: {
				'Content-Type': 'application/json'
			}
		}).then((r) => r.json());

		if (data.errorType) throw { reason: data.description };

		return { id: data, waitForOrder: waitForOrder({ uid: data, trader: fromAddress, chain }) };
	}
}

export const getTxData = () => '';

export const getTx = () => ({});

```

`interface/src/components/Aggregator/adapters/firebird.ts`:

```ts
import BigNumber from 'bignumber.js';
import { chainsMap, defillamaReferrerAddress } from '../constants';
import { ExtraData } from '../types';
import { applyArbitrumFees } from '../utils/arbitrumFees';
import { sendTx } from '../utils/sendTx';
import { zeroAddress } from 'viem';
import { estimateGas } from 'wagmi/actions';
import { config } from '../../WalletProvider';

export const chainToId = {
	ethereum: chainsMap.ethereum,
	bsc: chainsMap.bsc,
	polygon: chainsMap.polygon,
	optimism: chainsMap.optimism,
	arbitrum: chainsMap.arbitrum,
	avax: chainsMap.avax,
	fantom: chainsMap.fantom,
	cronos: chainsMap.cronos,
	canto: chainsMap.canto,
	base: chainsMap.base,
	zksync: chainsMap.zksync
	//opBNB
	//pulse
};

const approvalAddresses = {
	ethereum: '0xe0C38b2a8D09aAD53f1C67734B9A95E43d5981c0',
	bsc: '0x92e4F29Be975C1B1eB72E77De24Dccf11432a5bd',
	polygon: '0xb31D1B1eA48cE4Bf10ed697d44B747287E785Ad4',
	optimism: '0x0c6134Abc08A1EafC3E2Dc9A5AD023Bb08Da86C3',
	arbitrum: '0x0c6134Abc08A1EafC3E2Dc9A5AD023Bb08Da86C3',
	avax: '0xe0C38b2a8D09aAD53f1C67734B9A95E43d5981c0',
	fantom: '0xe0C38b2a8D09aAD53f1C67734B9A95E43d5981c0',
	cronos: '0x4A5a7331dA84d3834C030a9b8d4f3d687A3b788b',
	canto: '0x984742Be1901fcbed70d7B5847bee5BE006d91C8',
	base: '0x20f0b18BDDe8e3dd0e42C173062eBdd05C421151',
	zksync: '0xc593dcfD1E4605a6Cd466f5C6807D444414dBc97'
};

export const name = 'Firebird';
export const token = 'HOPE';

export function approvalAddress(chain: string) {
	return approvalAddresses[chain];
}

const routerAPI = 'https://router.firebird.finance/aggregator/v2';
const headers = {
	'content-type': 'application/json',
	'api-key': 'firebird_defillama'
};
const nativeToken = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';

export async function getQuote(chain: string, from: string, to: string, amount: string, extra: ExtraData) {
	const isFromNative = from === zeroAddress;
	const tokenFrom = isFromNative ? nativeToken : from;
	const tokenTo = to === zeroAddress ? nativeToken : to;
	const receiver = extra.userAddress || defillamaReferrerAddress;

	// amount should include decimals
	const result = await fetch(
		`${routerAPI}/quote?chainId=${
			chainToId[chain]
		}&from=${tokenFrom}&to=${tokenTo}&amount=${amount}&receiver=${receiver}&slippage=${
			+extra.slippage / 100
		}&source=defillama&ref=${defillamaReferrerAddress}`,
		{ headers }
	).then((r) => r.json());
	const data = result.quoteData;

	const { encodedData } = await fetch(`${routerAPI}/encode`, {
		method: 'POST',
		headers,
		body: JSON.stringify(result)
	}).then((r) => r.json());

	let estimatedGas;
	let value = isFromNative ? BigInt(amount) : undefined;
	try {
		estimatedGas = (
			await estimateGas(config, {
				to: encodedData.router,
				data: encodedData.data,
				value,
				chainId: chainsMap[chain]
			})
		).toString();
	} catch (e) {
		estimatedGas = data.maxReturn.totalGas;
	}

	if (estimatedGas) {
		if (chain === 'optimism') estimatedGas = BigNumber(3.5).times(estimatedGas).toFixed(0, 1);
		if (chain === 'arbitrum')
			estimatedGas = await applyArbitrumFees(encodedData.router, encodedData.data, estimatedGas);
	}

	return {
		amountReturned: data.maxReturn.totalTo,
		estimatedGas,
		tokenApprovalAddress: encodedData.router,
		rawQuote: { ...data, tx: { ...encodedData, from: receiver, value, gasLimit: estimatedGas } },
		logo: 'https://assets.coingecko.com/markets/images/730/small/firebird-finance.png?1636117048'
	};
}

export async function swap({ rawQuote, chain }) {
	const tx = await sendTx({
		from: rawQuote.tx.from,
		to: rawQuote.tx.router,
		data: rawQuote.tx.data,
		value: rawQuote.tx.value,
		...(chain === 'optimism' && { gas: rawQuote.gasLimit })
	});

	return tx;
}

export const getTxData = ({ rawQuote }) => rawQuote?.tx?.data;

export const getTx = ({ rawQuote }) => ({ ...rawQuote?.tx, to: rawQuote?.tx?.router });

```

`interface/src/components/Aggregator/adapters/hashflow/abi.ts`:

```ts
export const ABI = [
	{
		inputs: [
			{
				components: [
					{
						internalType: 'address',
						name: 'pool',
						type: 'address'
					},
					{
						internalType: 'address',
						name: 'externalAccount',
						type: 'address'
					},
					{
						internalType: 'address',
						name: 'trader',
						type: 'address'
					},
					{
						internalType: 'address',
						name: 'effectiveTrader',
						type: 'address'
					},
					{
						internalType: 'address',
						name: 'baseToken',
						type: 'address'
					},
					{
						internalType: 'address',
						name: 'quoteToken',
						type: 'address'
					},
					{
						internalType: 'uint256',
						name: 'effectiveBaseTokenAmount',
						type: 'uint256'
					},
					{
						internalType: 'uint256',
						name: 'maxBaseTokenAmount',
						type: 'uint256'
					},
					{
						internalType: 'uint256',
						name: 'maxQuoteTokenAmount',
						type: 'uint256'
					},
					{
						internalType: 'uint256',
						name: 'quoteExpiry',
						type: 'uint256'
					},
					{
						internalType: 'uint256',
						name: 'nonce',
						type: 'uint256'
					},
					{
						internalType: 'bytes32',
						name: 'txid',
						type: 'bytes32'
					},
					{
						internalType: 'bytes',
						name: 'signature',
						type: 'bytes'
					}
				],
				internalType: 'struct IQuote.RFQTQuote',
				name: 'quote',
				type: 'tuple'
			}
		],
		name: 'tradeSingleHop',
		outputs: [],
		stateMutability: 'payable',
		type: 'function'
	}
] as const;

```

`interface/src/components/Aggregator/adapters/hashflow/index.ts`:

```ts
import BigNumber from 'bignumber.js';
import { applyArbitrumFees } from '../../utils/arbitrumFees';
import { sendTx } from '../../utils/sendTx';
import { ABI } from './abi';
import { encodeFunctionData, zeroAddress } from 'viem';

export const chainToId = {
	ethereum: 1
	/*
	bsc: 56,
	polygon: 137,
	arbitrum: 42161,
	avax: 43114,
	optimism: 10
	*/
};

export const name = 'Hashflow';
export const token = 'HFT';
export const isOutputAvailable = true;

// from https://docs.hashflow.com/hashflow/taker/getting-started#5.-execute-quote-on-chain
const routerAddress = {
	1: '0xF6a94dfD0E6ea9ddFdFfE4762Ad4236576136613',
	10: '0xb3999F658C0391d94A37f7FF328F3feC942BcADC',
	56: '0x0ACFFB0fb2cddd9BD35d03d359F3D899E32FACc9',
	137: '0x72550597dc0b2e0beC24e116ADd353599Eff2E35',
	42161: '0x1F772fA3Bc263160ea09bB16CE1A6B8Fc0Fab36a',
	43114: '0x64D2f9F44FE26C157d552aE7EAa613Ca6587B59e'
};

export async function getQuote(chain: string, from: string, to: string, amount: string, extra) {
	const amountParam =
		extra.amountOut && extra.amountOut !== '0' ? { quoteTokenAmount: extra.amountOut } : { baseTokenAmount: amount };

	const data = await fetch(`https://api.hashflow.com/taker/v2/rfq`, {
		method: 'POST',
		body: JSON.stringify({
			networkId: chainToId[chain],
			source: 'defillama',
			rfqType: 0,
			baseToken: from,
			quoteToken: to,
			trader: extra.userAddress,
			...amountParam
		}),
		headers: {
			'Content-Type': 'application/json',
			Authorization: process.env.HASHFLOW_API_KEY as string
		}
	}).then((r) => r.json());
	const gas = chain === 'optimism' ? BigNumber(3.5).times(data.gasEstimate).toFixed(0, 1) : data.gasEstimate;

	// https://docs.hashflow.com/hashflow/taker/getting-started#5.-execute-quote-on-chain
	const encodedData = encodeFunctionData({
		abi: ABI,
		args: [
			{
				pool: data.quoteData.pool as `0x${string}`,
				externalAccount: data.quoteData.eoa ?? (zeroAddress as `0x${string}`),
				trader: data.quoteData.trader as `0x${string}`,
				effectiveTrader: data.quoteData.effectiveTrader ?? (data.quoteData.trader as `0x${string}`),
				baseToken: data.quoteData.baseToken as `0x${string}`,
				quoteToken: data.quoteData.quoteToken as `0x${string}`,
				effectiveBaseTokenAmount: data.quoteData.baseTokenAmount as any,
				maxBaseTokenAmount: data.quoteData.baseTokenAmount as any,
				maxQuoteTokenAmount: data.quoteData.quoteTokenAmount as any,
				quoteExpiry: data.quoteData.quoteExpiry as any,
				nonce: data.quoteData.nonce as any,
				txid: data.quoteData.txid as `0x${string}`,
				signature: data.signature as `0x${string}`
			}
		]
	});

	const txData = {
		to: routerAddress[chainToId[chain]],
		data: encodedData
	};

	let estimatedGas = gas;
	if (chain === 'arbitrum') estimatedGas = await applyArbitrumFees(txData.to, txData.data, gas);

	const timeTillExpiry = data.quoteData.quoteExpiry - Date.now() / 1000;
	if (timeTillExpiry < 40) {
		throw new Error('Expiry is too close');
	}

	return {
		amountReturned: data?.quoteData?.quoteTokenAmount || 0,
		amountIn: data?.quoteData?.baseTokenAmount || 0,
		estimatedGas,
		tokenApprovalAddress: routerAddress[chainToId[chain]],
		validTo: data.quoteData.quoteExpiry,
		rawQuote: {
			...data,
			gasLimit: estimatedGas,
			tx: { ...txData, ...(from === zeroAddress ? { value: data.quoteData.baseTokenAmount } : {}) }
		},
		isMEVSafe: true
	};
}

export async function swap({ rawQuote, chain }) {
	const tx = await sendTx({
		...rawQuote.tx,
		...(chain === 'optimism' && { gas: rawQuote.tx.gasLimit })
	});

	return tx;
}

export const getTxData = ({ rawQuote }) => rawQuote?.tx?.data;

export const getTx = ({ rawQuote }) => rawQuote.tx;

```

`interface/src/components/Aggregator/adapters/krystal.ts`:

```ts
import BigNumber from 'bignumber.js';

export const chainToId = {
	ethereum: 'ethereum',
	bsc: 'bsc',
	polygon: 'polygon',
	avax: 'avalanche',
	cronos: 'cronos',
	fantom: 'fantom',
	arbitrum: 'arbitrum',
	aurora: 'aurora',
	klaytn: 'klaytn'
};

export const name = 'Krystal';
export const token = null;

export function approvalAddress(chain: string) {
	return ''; // need to fix
}

export async function getQuote(chain: string, from: string, to: string, amount: string) {
	// gas token is 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
	const data = await fetch(
		`https://api.krystal.app/${chainToId[chain]}/v2/swap/allRates?src=${from}&srcAmount=${amount}&dest=${to}&platformWallet=0x168E4c3AC8d89B00958B6bE6400B066f0347DDc9`
	).then((r) => r.json());

	const estimatedGas =
		chain === 'optimism' ? BigNumber(3.5).times(data.rates[0].estimatedGas).toFixed(0, 1) : data.rates[0].estimatedGas;

	return {
		amountReturned: data.rates[0].amount,
		estimatedGas
	};
}

```

`interface/src/components/Aggregator/adapters/kyberswap.ts`:

```ts
import { ExtraData } from '../types';
import { sendTx } from '../utils/sendTx';
import { zeroAddress } from 'viem';

// https://docs.kyberswap.com/kyberswap-solutions/kyberswap-aggregator/aggregator-api-specification/evm-swaps
export const chainToId = {
	ethereum: 'ethereum',
	bsc: 'bsc',
	polygon: 'polygon',
	optimism: 'optimism',
	arbitrum: 'arbitrum',
	avax: 'avalanche',
	fantom: 'fantom',
	zksync: 'zksync',
	polygonzkevm: 'polygon-zkevm',
	linea: 'linea',
	base: 'base',
	scroll: 'scroll',
	sonic: 'sonic',
	//mantle
	//blast

	// removed
	// cronos: 'cronos',
	// aurora: 'aurora',
	// bttc: 'bttc',
};

const universalRouter = "0x6131b5fae19ea4f9d964eac0408e4408b66337b5"

const routers = {
	ethereum: universalRouter,
	bsc: universalRouter,
	polygon: universalRouter,
	optimism: universalRouter,
	arbitrum: universalRouter,
	avax: universalRouter,
	fantom: universalRouter,
	zksync: '0x3F95eF3f2eAca871858dbE20A93c01daF6C2e923',
	polygonzkevm: universalRouter,
	linea: universalRouter,
	base: universalRouter,
	scroll: universalRouter,
	sonic: universalRouter,
}

export const name = 'KyberSwap';
export const token = 'KNC';

export function approvalAddress() {
	return universalRouter;
}

const nativeToken = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
const clientId = "llamaswap"

export async function getQuote(chain: string, from: string, to: string, amount: string, extra: ExtraData) {
	const tokenFrom = from === zeroAddress ? nativeToken : from;
	const tokenTo = to === zeroAddress ? nativeToken : to;

	const quote = await fetch(
		`https://aggregator-api.kyberswap.com/${
			chainToId[chain]
		}/api/v1/routes?tokenIn=${tokenFrom}&tokenOut=${tokenTo}&amountIn=${amount}&gasInclude=true`,
		{
			headers: {
				'x-client-id': clientId
			}
		}
	).then((r) => r.json());

	const tx = extra.userAddress === zeroAddress? null : await fetch(
		`https://aggregator-api.kyberswap.com/${chainToId[chain]}/api/v1/route/build`,
		{
			headers: {
				'x-client-id': clientId
			},
			method: "POST",
			body: JSON.stringify({
				routeSummary: quote.data.routeSummary, 
				sender: extra.userAddress,
				recipient: extra.userAddress,
				slippageTolerance: +extra.slippage * 100,
				source: clientId
			})
		}
	).then((r) => r.json());

	let gas = tx === null? quote.data.routeSummary.gas : tx.data.gas;

	if(tx !== null){
		if(routers[chain].toLowerCase() !== tx.data.routerAddress.toLowerCase()){
			throw new Error("Approval address doesn't match hardcoded one")
		}
	}

	return {
		amountReturned: tx === null? quote.data.routeSummary.amountOut: tx.data.amountOut,
		estimatedGas: gas,
		tokenApprovalAddress: routers[chain],
		rawQuote: tx === null? {} : tx.data,
		logo: 'https://assets.coingecko.com/coins/images/14899/small/RwdVsGcw_400x400.jpg?1618923851'
	};
}

export async function swap({ fromAddress, from, rawQuote }) {
	const transactionOption: Record<string, string> = {
		from: fromAddress,
		to: rawQuote.routerAddress,
		data: rawQuote.data,
	};

	if (from === zeroAddress) transactionOption.value = rawQuote.amountIn;

	const tx = await sendTx(transactionOption);

	return tx;
}
export const getTxData = ({ rawQuote }) => rawQuote?.data;

export const getTx = ({ rawQuote }) => ({
	to: rawQuote.routerAddress,
	data: rawQuote.data
});

```

`interface/src/components/Aggregator/adapters/lifi.ts`:

```ts
// Source https://docs.1inch.io/docs/aggregation-protocol/api/swagger

import BigNumber from 'bignumber.js';
import { ExtraData } from '../types';
import { zeroAddress } from 'viem';
import { sendTx } from '../utils/sendTx';

export const chainToId = {
	ethereum: 'eth',
	polygon: 'pol',
	bsc: 'bsc',
	gnosis: 'dai',
	fantom: 'ftm',
	avax: 'ava',
	arbitrum: 'arb',
	optimism: 'opt',
	moonriver: 'mor',
	moonbeam: 'moo',
	celo: 'cel',
	fuse: 'fus',
	cronos: 'cro',
	velas: 'vel',
	aurora: 'aur'
};
export const name = 'LI.FI';
export const token = null;

const nativeToken = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';

export async function getQuote(chain: string, from: string, to: string, amount: string, extra: ExtraData) {
	// ethereum = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE
	// amount should include decimals

	const tokenFrom = from === zeroAddress ? nativeToken : from;
	const tokenTo = to === zeroAddress ? nativeToken : to;
	const data = await fetch(
		`https://li.quest/v1/quote?fromChain=${chainToId[chain]}&toChain=${
			chainToId[chain]
		}&fromToken=${tokenFrom}&toToken=${tokenTo}&fromAmount=${amount}&fromAddress=${
			extra.userAddress === zeroAddress ? '0x1000000000000000000000000000000000000001' : extra.userAddress
		}&slippage=${+extra.slippage / 100}`
	).then((r) => r.json());

	const gas = data.estimate.gasCosts.reduce((acc, val) => acc + Number(val.estimate), 0);

	const estimatedGas = chain === 'optimism' ? BigNumber(3.5).times(gas).toFixed(0, 1) : gas;

	return {
		amountReturned: data.estimate.toAmount,
		estimatedGas,
		tokenApprovalAddress: data.estimate.approvalAddress,
		logo: '',
		rawQuote: { ...data, gasLimit: estimatedGas }
	};
}

export async function swap({ rawQuote, chain }) {
	const tx = await sendTx({
		from: rawQuote.transactionRequest.from,
		to: rawQuote.transactionRequest.to,
		data: rawQuote.transactionRequest.data,
		value: rawQuote.transactionRequest.value,
		...(chain === 'optimism' && { gas: rawQuote.gasLimit })
	});

	return tx;
}

export const getTxData = ({ rawQuote }) => rawQuote?.transactionRequest?.data;

export const getTx = ({ rawQuote }) => ({
	from: rawQuote.transactionRequest.from,
	to: rawQuote.transactionRequest.to,
	data: rawQuote.transactionRequest.data,
	value: rawQuote.transactionRequest.value
});

```

`interface/src/components/Aggregator/adapters/llamazip/encode.ts`:

```ts
function countBits(inputNum: bigint) {
	let bitlength = 0;
	while (inputNum !== 0n) {
		inputNum = inputNum / 2n;
		bitlength++;
	}
	return bitlength;
}

function removeFirstBit(word: bigint) {
	// To work this requires that word has a number of bits that is multiple of 8 + the starting bit
	return word.toString(16).slice(1);
}

export function encode(
	pair: string,
	token0IsTokenIn: boolean,
	expectedReturnAmount: string,
	slippage: string,
	inputIsETH: boolean,
	maxBalance?: boolean,
	inputAmount?: string
) {
	let word = ((1n << 4n) + BigInt(pair)) << 1n;
	if (token0IsTokenIn) {
		word = word + 1n;
	}
	word = word << 17n;
	let slippageZeroes = 0n;
	let slippageNum = BigInt(expectedReturnAmount);
	while (slippageNum > 131071n) {
		// 0b11111111111111111
		slippageZeroes++;
		slippageNum = slippageNum / 2n;
	}
	if (slippageNum < 131071n) {
		slippageNum = slippageNum + 1n; // round up
	}
	word = ((word + slippageNum) << 8n) + slippageZeroes;

	const slippageId = ['0.5', '0.1', '1', '5'].findIndex((slip) => slip === slippage);
	if (slippageId === -1) {
		throw new Error('Slippage number not supported');
	}
	word = (word << 2n) + BigInt(slippageId);

	if (inputIsETH || maxBalance) {
		return removeFirstBit(word); // pad it so total number of bits is a multiple of 8
	}

	let inputZeroes = 0n;
	let inputNum = BigInt(inputAmount!);
	while ((inputNum % 10n) === 0n && inputNum !== 0n) {
		inputZeroes++;
		inputNum = inputNum / 10n;
	}
	word = (word << 5n) + inputZeroes;
	const inputBitlength = BigInt(countBits(inputNum));
	const extraBits = inputBitlength % 8n;
	word = word << (inputBitlength + (extraBits <= 3n ? 3n - extraBits : 3n + 8n - extraBits));
	return removeFirstBit(word + inputNum);
}

```

`interface/src/components/Aggregator/adapters/llamazip/index.ts`:

```ts
import { sendTx } from '../../utils/sendTx';
import { encode } from './encode';
import { normalizeTokens, pairs } from './pairs';
import { zeroAddress } from 'viem';
import { simulateContract } from 'wagmi/actions';
import { config } from '../../../WalletProvider';
import { chainsMap } from '../../constants';

export const name = 'LlamaZip';
export const token = 'none';

export const chainToId = {
	optimism: '0x6f9d14Cf4A06Dd9C70766Bd161cf8d4387683E1b',
	arbitrum: '0x973bf562407766e77f885c1cd1a8060e5303C745'
};

// https://docs.uniswap.org/contracts/v3/reference/deployments
const quoter = {
	optimism: '0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6',
	arbitrum: '0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6'
};

const weth = {
	optimism: '0x4200000000000000000000000000000000000006',
	arbitrum: '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1'
};

function normalize(token: string, weth: string) {
	return (token === zeroAddress ? weth : token).toLowerCase();
}

// https://docs.uniswap.org/sdk/v3/guides/quoting
export async function getQuote(chain: string, from: string, to: string, amount: string, extra: any) {
	if (to.toLowerCase() === weth[chain].toLowerCase()) {
		return null; // We don't support swaps to WETH
	}

	const tokenFrom = normalize(from, weth[chain]);
	const tokenTo = normalize(to, weth[chain]);

	const token0isTokenIn = BigInt(tokenFrom) < BigInt(tokenTo);

	const possiblePairs = pairs[chain as keyof typeof pairs].filter(
		({ name }) => name === normalizeTokens(tokenFrom, tokenTo).join('-')
	);

	if (possiblePairs.length === 0) {
		return null;
	}

	const quotedAmountOuts = (
		await Promise.all(
			possiblePairs.map(async (pair) => {
				try {
					// const callData = encodeFunctionData({})
					return {
						output: (
							await simulateContract(config, {
								address: quoter[chain],
								abi: [
									{
										inputs: [
											{ internalType: 'address', name: 'tokenIn', type: 'address' },
											{ internalType: 'address', name: 'tokenOut', type: 'address' },
											{ internalType: 'uint24', name: 'fee', type: 'uint24' },
											{ internalType: 'uint256', name: 'amountIn', type: 'uint256' },
											{ internalType: 'uint160', name: 'sqrtPriceLimitX96', type: 'uint160' }
										],
										name: 'quoteExactInputSingle',
										outputs: [{ internalType: 'uint256', name: 'amountOut', type: 'uint256' }],
										stateMutability: 'nonpayable',
										type: 'function'
									}
								],
								functionName: 'quoteExactInputSingle',
								args: [tokenFrom as `0x${string}`, tokenTo as `0x${string}`, Number(pair.fee), BigInt(amount), 0n],
								chainId: chainsMap[chain]
							})
						).result,
						pair
					};
				} catch (e) {
					console.log({ e });
					if (pair.mayFail === true) return null;
					throw e;
				}
			})
		)
	).filter((t) => t !== null);

	const bestPair = quotedAmountOuts.sort((a, b) => (b!.output > a!.output ? 1 : -1))[0];
	const pair = bestPair!.pair;
	const quotedAmountOut = bestPair!.output.toString();

	const inputIsETH = from === zeroAddress;
	const calldata = encode(pair.pairId, token0isTokenIn, quotedAmountOut, extra.slippage, inputIsETH, false, amount);
	if (calldata.length > 256 / 4 + 2) {
		return null; // LlamaZip doesn't support calldata that's bigger than one EVM word
	}

	return {
		amountReturned: quotedAmountOut.toString(),
		estimatedGas: (200e3).toString(), // random approximation
		rawQuote: {
			tx: {
				to: chainToId[chain],
				data: calldata,
				...(inputIsETH ? { value: amount } : {})
			}
		},
		tokenApprovalAddress: chainToId[chain],
		logo: 'https://raw.githubusercontent.com/DefiLlama/memes/master/bussin.jpg'
	};
}

export async function swap({ fromAddress, rawQuote }) {
	const tx = await sendTx({
		from: fromAddress,
		to: rawQuote.tx.to,
		data: rawQuote.tx.data,
		value: rawQuote.tx.value
	});
	return tx;
}

export const getTxData = ({ rawQuote }) => rawQuote?.tx?.data;

export const getTx = ({ rawQuote }) => rawQuote?.tx;

```

`interface/src/components/Aggregator/adapters/llamazip/pairs.ts`:

```ts
export const tokens = {
	optimism: {
		weth: '0x4200000000000000000000000000000000000006',
		usdc: '0x7F5c764cBc14f9669B88837ca1490cCa17c31607',
		op: '0x4200000000000000000000000000000000000042',
		snx: '0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4',
		dai: '0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1',
		susd: '0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9',
		wbtc: '0x68f180fcCe6836688e9084f035309E29Bf0A2095',
		thales: '0x217D47011b23BB961eB6D93cA9945B7501a5BB11',
		usdt: '0x94b008aA00579c1307B0EF2c499aD98a8ce58e58',
		perp: '0x9e1028F5F1D5eDE59748FFceE5532509976840E0',
		velo: '0x3c8B650257cFb5f272f799F5e2b4e65093a11a05'
	},
	arbitrum: {
		weth: '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1',
		usdc: '0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8',
		usdt: '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9',
		gmx: '0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a',
		dai: '0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1',
		wbtc: '0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f',
		gns: '0x18c11FD286C5EC11c3b683Caa813B77f5163A122',
		magic: '0x539bdE0d7Dbd336b79148AA742883198BBF60342',
		arb: '0x912CE59144191C1204E64559FE8253a0e49E6548'
	}
};

export const normalizeTokens = (t0, t1) =>
	BigInt(t0) < BigInt(t1) ? [t0.toLowerCase(), t1.toLowerCase()] : [t1.toLowerCase(), t0.toLowerCase()];

const createPair = (t0: string, t1: string, fee: string, pairId: string, mayFail: boolean = false) => {
	const [token0, token1] = normalizeTokens(t0, t1);

	return {
		name: `${token0}-${token1}`,
		pairId,
		token0,
		token1,
		fee,
		mayFail
	};
};

export const pairs = {
	optimism: (() => {
		const chainTokens = tokens.optimism;
		return [
			createPair(chainTokens.weth, chainTokens.usdc, '500', '0'),
			createPair(chainTokens.weth, chainTokens.op, '3000', '1'),
			createPair(chainTokens.op, chainTokens.usdc, '3000', '2'),
			createPair(chainTokens.weth, chainTokens.op, '500', '3'),
			createPair(chainTokens.usdc, chainTokens.dai, '100', '4'),
			createPair(chainTokens.snx, chainTokens.weth, '3000', '5'),
			createPair(chainTokens.weth, chainTokens.dai, '3000', '6')
		];
	})(),
	arbitrum: (() => {
		const chainTokens = tokens.arbitrum;

		return [
			createPair(chainTokens.weth, chainTokens.usdc, '500', '0'),
			createPair(chainTokens.weth, chainTokens.usdt, '500', '1'),
			createPair(chainTokens.weth, chainTokens.wbtc, '500', '2'),
			createPair(chainTokens.weth, chainTokens.gmx, '3000', '3'),
			createPair(chainTokens.weth, chainTokens.gns, '3000', '4'),
			createPair(chainTokens.weth, chainTokens.magic, '10000', '5'),
			createPair(chainTokens.weth, chainTokens.dai, '3000', '6'),
			createPair(chainTokens.weth, chainTokens.arb, '10000', '7'),
			createPair(chainTokens.weth, chainTokens.arb, '3000', '8', true),
			createPair(chainTokens.weth, chainTokens.arb, '500', '9', true),
			createPair(chainTokens.weth, chainTokens.arb, '100', '10', true)
		];
	})()
};

```

`interface/src/components/Aggregator/adapters/odos/index.ts`:

```ts
import { sendTx } from '../../utils/sendTx';

// https://api.odos.xyz/info/chains
export const chainToId = {
	ethereum: 1,
	arbitrum: 42161,
	optimism: 10,
	base: 8453,
	polygon: 137,
	avax: 43114,
	bsc: 56,
	fantom: 250,
	zksync: 324,
	//polygonzkevm: 1101
	//mantle
	//mode:
	linea: 59144,
	scroll: 534352,
	sonic: 146
};

export const name = 'Odos';
export const token = 'ODOS';

const referralCode = 2101375859;

// https://docs.odos.xyz/product/sor/v2/
const routers = {
	ethereum: '0xcf5540fffcdc3d510b18bfca6d2b9987b0772559',
	arbitrum: '0xa669e7a0d4b3e4fa48af2de86bd4cd7126be4e13',
	optimism: '0xca423977156bb05b13a2ba3b76bc5419e2fe9680',
	base: '0x19ceead7105607cd444f5ad10dd51356436095a1',
	polygon: '0x4e3288c9ca110bcc82bf38f09a7b425c095d92bf',
	avax: '0x88de50b233052e4fb783d4f6db78cc34fea3e9fc',
	bsc: '0x89b8aa89fdd0507a99d334cbe3c808fafc7d850e',
	fantom: '0xd0c22a5435f4e8e5770c1fafb5374015fc12f7cd',
	zksync: '0x4bBa932E9792A2b917D47830C93a9BC79320E4f7',
	linea: '0x2d8879046f1559E53eb052E949e9544bCB72f414',
	scroll: '0xbFe03C9E20a9Fc0b37de01A172F207004935E0b1',
	sonic: '0xac041df48df9791b0654f1dbbf2cc8450c5f2e9d',
	//polygonzkevm: '0x2b8B3f0949dfB616602109D2AAbBA11311ec7aEC'
};

export function approvalAddress(chain) {
	return routers[chain];
}

export async function getQuote(chain: string, from: string, to: string, amount: string, extra) {
	const quote = await fetch(`https://api.odos.xyz/sor/quote/v2`, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({
			chainId: chainToId[chain],
			inputTokens: [
				{
					tokenAddress: from,
					amount: amount
				}
			],
			outputTokens: [
				{
					tokenAddress: to,
					proportion: 1
				}
			],
			userAddr: extra.userAddress, // checksummed user address
			slippageLimitPercent: extra.slippage, // set your slippage limit percentage (1 = 1%),
			referralCode,
			// optional:
			disableRFQs: true,
			compact: true
		})
	}).then((res) => res.json());

	const swapData = await fetch('https://api.odos.xyz/sor/assemble', {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({
			userAddr: extra.userAddress, // the checksummed address used to generate the quote
			pathId: quote.pathId // Replace with the pathId from quote response in step 1
			//simulate: true // this can be set to true if the user isn't doing their own estimate gas call for the transaction
		})
	}).then((res) => res.json());

	if (swapData.transaction.to.toLowerCase() !== routers[chain].toLowerCase()) {
		throw new Error(`Router address does not match`);
	}

	return {
		amountReturned: swapData.outputTokens[0].amount,
		estimatedGas: swapData.transaction.gas <= 0 ? swapData.gasEstimate : swapData.transaction.gas,
		rawQuote: swapData,
		tokenApprovalAddress: routers[chain]
	};
}

export async function swap({ rawQuote }) {
	const tx = await sendTx({
		from: rawQuote.transaction.from,
		to: rawQuote.transaction.to,
		data: rawQuote.transaction.data,
		value: rawQuote.transaction.value
		//gas: rawQuote.transaction.gas
	});

	return tx;
}

export const getTxData = ({ rawQuote }) => rawQuote?.transaction.data;

export const getTx = ({ rawQuote }) => ({
	to: rawQuote.transaction.to,
	data: rawQuote.transaction.data,
	value: rawQuote.transaction.value
});

```

`interface/src/components/Aggregator/adapters/openocean.ts`:

```ts
import { sendTx } from '../utils/sendTx';
import { zeroAddress } from 'viem';

export const chainToId = {
	//ethereum: 1,
	//bsc: 56,
	//polygon: 137,
	//optimism: 10,
	//arbitrum: 42161,
	gnosis: 100,
	//avax: 43114,
	fantom: 250,
	aurora: 1313161554,
	heco: 128,
	boba: 288,
	okexchain: 66,
	cronos: 25,
	moonriver: 1285,
	//ontology: 58,
	polygonzkevm: 1101,
	kava: 2222,
	metis: 1088,
	zksync: 324,
	linea: 59144,
	//base: 8453,
	//starknet
	//telos
	celo: 42220,
	scroll: 534352
	//harmony
	//tron
};

// https://docs.openocean.finance/dev/contracts-of-chains#openoceans-current-contract-addresses
const approvaAddressByChain = {
	polygonzkevm: '0x6dd434082EAB5Cd134B33719ec1FF05fE985B97b',
	zksync: '0x36A1aCbbCAfca2468b85011DDD16E7Cb4d673230',
	linea: '0x6352a56caadC4F1E25CD6c75970Fa768A3304e64',
	okexchain: '0xc0006Be82337585481044a7d11941c0828FFD2D4'
};

export const name = 'OpenOcean';
export const token = 'OOE';

export function approvalAddress() {
	return '0x6352a56caadc4f1e25cd6c75970fa768a3304e64';
}

// https://docs.openocean.finance/dev/openocean-api-3.0/quick-start
// the api from their docs is broken
// eg: https://open-api.openocean.finance/v3/eth/quote?inTokenAddress=0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9&outTokenAddress=0x8888801af4d980682e47f1a9036e589479e835c5&amount=100000000000000000000&gasPrice=400000000
// returns a AAVE->MPH trade that returns 10.3k MPH, when in reality that trade only gets you 3.8k MPH
// Replaced API with the one you get from snooping in their frontend, which works fine
export async function getQuote(chain: string, from: string, to: string, amount: string, { slippage, userAddress }) {
	const gasPrice = await fetch(`https://ethapi.openocean.finance/v2/${chainToId[chain]}/gas-price`).then((r) =>
		r.json()
	);
	const data = await fetch(
		`https://ethapi.openocean.finance/v2/${
			chainToId[chain]
		}/swap?inTokenAddress=${from}&outTokenAddress=${to}&amount=${amount}&gasPrice=${
			gasPrice.fast?.maxFeePerGas ?? gasPrice.fast
		}&slippage=${+slippage * 100}&account=${
			userAddress || zeroAddress
		}&referrer=0x5521c3dfd563d48ca64e132324024470f3498526`
	).then((r) => r.json());

	let gas = data.estimatedGas;

	return {
		amountReturned: data.outAmount,
		estimatedGas: gas,
		tokenApprovalAddress: approvaAddressByChain[chain] ?? '0x6352a56caadc4f1e25cd6c75970fa768a3304e64',
		rawQuote: { ...data, gasLimit: gas },
		logo: 'https://assets.coingecko.com/coins/images/17014/small/ooe_log.png?1626074195'
	};
}

export async function swap({ rawQuote, chain }) {
	const tx = await sendTx({
		from: rawQuote.from,
		to: rawQuote.to,
		data: rawQuote.data,
		value: rawQuote.value,
	});
	return tx;
}

export const getTxData = ({ rawQuote }) => rawQuote?.data;

export const getTx = ({ rawQuote }) => ({
	from: rawQuote.from,
	to: rawQuote.to,
	data: rawQuote.data,
	value: rawQuote.value
});

```

`interface/src/components/Aggregator/adapters/paraswap.ts`:

```ts
// Source: https://developers.paraswap.network/api/master

import { sendTx } from '../utils/sendTx';
import { defillamaReferrerAddress } from '../constants';
import { zeroAddress } from 'viem';

// api docs have an outdated chain list, need to check https://app.paraswap.io/# to find supported networks
export const chainToId = {
	ethereum: 1,
	bsc: 56,
	polygon: 137,
	avax: 43114,
	arbitrum: 42161,
	fantom: 250,
	optimism: 10,
	polygonzkevm: 1101,
	base: 8453,
	gnosis: 100
};

const approvers = {
	ethereum: "0x6a000f20005980200259b80c5102003040001068",
	bsc: "0x6a000f20005980200259b80c5102003040001068",
	polygon: "0x6a000f20005980200259b80c5102003040001068",
	avax: "0x6a000f20005980200259b80c5102003040001068",
	arbitrum: "0x6a000f20005980200259b80c5102003040001068",
	fantom: "0x6a000f20005980200259b80c5102003040001068",
	optimism: "0x6a000f20005980200259b80c5102003040001068",
	polygonzkevm: "0x6a000f20005980200259b80c5102003040001068",
	base: "0x6a000f20005980200259b80c5102003040001068",
	gnosis: "0x6a000f20005980200259b80c5102003040001068"
}

export const name = 'ParaSwap';
export const token = 'PSP';
export const partner = 'llamaswap';
export const isOutputAvailable = true;

export function approvalAddress() {
	return '0x216b4b4ba9f3e719726886d34a177484278bfcae';
}
const nativeToken = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
export async function getQuote(
	chain: string,
	from: string,
	to: string,
	amount: string,
	{ fromToken, toToken, userAddress, slippage, amountOut }
) {
	// ethereum = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE
	// amount should include decimals

	const tokenFrom = from === zeroAddress ? nativeToken : from;
	const tokenTo = to === zeroAddress ? nativeToken : to;
	const side = amountOut && amountOut !== '0' ? 'BUY' : 'SELL';
	const finalAmount = side === 'BUY' ? amountOut : amount;
	const data = await fetch(
		`https://apiv5.paraswap.io/prices/?srcToken=${tokenFrom}&destToken=${tokenTo}&amount=${finalAmount}&srcDecimals=${fromToken?.decimals}&destDecimals=${toToken?.decimals}&partner=${partner}&side=${side}&network=${chainToId[chain]}&excludeDEXS=ParaSwapPool,ParaSwapLimitOrders&version=6.2`
	).then((r) => r.json());

	const dataSwap =
		userAddress !== zeroAddress
			? await fetch(`https://apiv5.paraswap.io/transactions/${chainToId[chain]}?ignoreChecks=true`, {
					method: 'POST',
					body: JSON.stringify({
						srcToken: data.priceRoute.srcToken,
						srcDecimals: data.priceRoute.srcDecimals,
						destToken: data.priceRoute.destToken,
						destDecimals: data.priceRoute.destDecimals,
						slippage: slippage * 100,
						userAddress: userAddress,
						partner: partner,
						partnerAddress: defillamaReferrerAddress,
						takeSurplus: true,
						priceRoute: data.priceRoute,
						isCapSurplus: true,
						...(side === 'BUY' ? { destAmount: data.priceRoute.destAmount } : { srcAmount: data.priceRoute.srcAmount })
					}),
					headers: {
						'Content-Type': 'application/json'
					}
				}).then((r) => r.json())
			: null;

	if (dataSwap?.error) {
		throw new Error(dataSwap.error)
	}

	let gas = data.priceRoute.gasCost;

	if(data.priceRoute.tokenTransferProxy.toLowerCase() !== approvers[chain].toLowerCase()){
		throw new Error("Approval address doesn't match")
	}

	return {
		amountReturned: data.priceRoute.destAmount,
		amountIn: data.priceRoute.srcAmount || 0,
		estimatedGas: gas,
		tokenApprovalAddress: data.priceRoute.tokenTransferProxy,
		rawQuote: { ...dataSwap, gasLimit: gas },
		logo: 'https://assets.coingecko.com/coins/images/20403/small/ep7GqM19_400x400.jpg?1636979120'
	};
}

export async function swap({ rawQuote, chain }) {
	const tx = await sendTx({
		from: rawQuote.from,
		to: rawQuote.to,
		data: rawQuote.data,
		value: rawQuote.value,
	});

	return tx;
}

export const getTxData = ({ rawQuote }) => rawQuote?.data;

export const getTx = ({ rawQuote }) => ({
	from: rawQuote.from,
	to: rawQuote.to,
	data: rawQuote.data,
	value: rawQuote.value
});

```

`interface/src/components/Aggregator/adapters/rango.ts`:

```ts
// Source https://docs.1inch.io/docs/aggregation-protocol/api/swagger

import BigNumber from 'bignumber.js';
import { zeroAddress } from 'viem';
import { estimateGas } from 'wagmi/actions';
import { config } from '../../WalletProvider';
import { chainsMap } from '../constants';

export const chainToId = {
	ethereum: 'ETH',
	bsc: 'BSC',
	polygon: 'POLYGON',
	optimism: 'OPTIMISM',
	arbitrum: 'ARBITRUM',
	gnosis: 'GNOSIS',
	avax: 'AVAX_CCHAIN',
	fantom: 'FANTOM',
	aurora: 'AURORA'
};

export const name = 'Rango';
export const token = null;

export async function getQuote(
	chain: string,
	from: string,
	to: string,
	amount: string,
	{ userAddress, fromToken, toToken, slippage }
) {
	// ethereum = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE
	// amount should include decimals

	const tokenFrom =
		fromToken.address === zeroAddress
			? `${chainToId[chain]}.${fromToken.symbol}`
			: `${chainToId[chain]}.${fromToken.symbol}--${fromToken.address}`;
	const tokenTo =
		toToken.address === zeroAddress
			? `${chainToId[chain]}.${toToken.symbol}`
			: `${chainToId[chain]}.${toToken.symbol}--${toToken.address}`;
	const params = new URLSearchParams({
		from: tokenFrom,
		to: tokenTo,
		amount: amount,
		fromAddress: userAddress || zeroAddress,
		toAddress: userAddress || zeroAddress,
		disableEstimate: 'true',
		apiKey: 'c0ed54c0-e85c-4547-8e11-7ff88775b90c',
		slippage: slippage || '1'
	}).toString();

	const data = await fetch(`https://api.rango.exchange/basic/swap?${params}`).then((r) => r.json());

	let estimatedGas;
	try {
		estimatedGas = (
			await estimateGas(config, {
				to: data?.tx?.txTo,
				data: data?.tx?.txData,
				value: data?.tx?.value,
				chainId: chainsMap[chain]
			})
		).toString();
	} catch (e) {
		estimatedGas = BigNumber(data?.tx?.gasLimit).toString();
	}

	const gasPrice =
		chain === 'optimism' && estimatedGas ? BigNumber(3.5).times(estimatedGas).toFixed(0, 1) : estimatedGas;

	return {
		amountReturned: data?.route?.outputAmount,
		estimatedGas: gasPrice,
		tokenApprovalAddress: data?.tx?.txTo,
		rawQuote: { ...data, gasLimit: gasPrice },
		logo: ''
	};
}

export async function swap({ signer, rawQuote, chain }) {
	const fromAddress = await signer.getAddress();

	const tx = await signer.sendTransaction({
		from: fromAddress,
		to: rawQuote?.tx?.txTo,
		data: rawQuote?.tx?.txData,
		value: rawQuote?.tx?.value,
		...(chain === 'optimism' && { gas: rawQuote.gasLimit })
	});

	return tx;
}

export const getTxData = ({ rawQuote }) => rawQuote?.tx?.txData;

```

`interface/src/components/Aggregator/adapters/unidex.ts`:

```ts
// Unidex aggregates many aggregators but their api only supports fantom
// Source: https://unidexexchange.gitbook.io/unidex/api-information/swap-aggregator/quote-swap
// IMPORTANT: their api is broken, this integration is disabled since it doesnt work

import BigNumber from 'bignumber.js';

export const chainToId = {
	fantom: 250
};

export const name = 'UniDex';
export const token = 'UNIDX';

export function approvalAddress() {
	return '0x216b4b4ba9f3e719726886d34a177484278bfcae';
}

export async function getQuote(chain: string, from: string, to: string, amount: string) {
	const data = await fetch(
		`https://unidexmirai.org/swap/v1/quote?sellToken=${from}&buyToken=${to}&sellAmount=${amount}`
	).then((r) => r.json());

	const estimatedGas = chain === 'optimism' ? BigNumber(3.5).times(data.estimatedGas).toFixed(0, 1) : data.estimatedGas;

	return {
		amountReturned: data.buyAmount,
		estimatedGas,
		tokenApprovalAddress: data.allowanceTarget
	};
}

```

`interface/src/components/Aggregator/adapters/utils.ts`:

```ts
export const redirectQuoteReq = async (
	protocol: string,
	chain: string,
	from: string,
	to: string,
	amount: string,
	extra: any
) => {
	const data = await fetch(
		`https://swap-api.defillama.com/dexAggregatorQuote?protocol=${encodeURIComponent(
			protocol
		)}&chain=${chain}&from=${from}&to=${to}&amount=${amount}&api_key=nsr_UYWxuvj1hOCgHxJhDEKZ0g30c4Be3I5fOMBtFAA`,
		{
			method: 'POST',
			body: JSON.stringify(extra)
		}
	).then((res) => res.json());

	return data;
};

interface SwapEvent {
	user: string;
	aggregator: string;
	isError: boolean;
	chain: string;
	from: string;
	to: string;
	quote: any;
	txUrl: string;
	amount: string;
	errorData: any;
	amountUsd: number | null;
	slippage: string;
	routePlace: string;
	route: any;
	reportedOutput?: number;
	realOutput?: number;
}

export const sendSwapEvent = async (event: SwapEvent) => {
	const data = await fetch(`https://llamaswap-stats.llama.fi/saveEvent`, {
		method: 'POST',
		body: JSON.stringify(event)
	}).then((res) => res.json());

	return data;
};

```

`interface/src/components/Aggregator/adapters/yieldyak/abi.ts`:

```ts
export const ABI = [
	{
		inputs: [
			{ internalType: 'uint256', name: '_amountIn', type: 'uint256' },
			{ internalType: 'address', name: '_tokenIn', type: 'address' },
			{ internalType: 'address', name: '_tokenOut', type: 'address' },
			{ internalType: 'uint256', name: '_maxSteps', type: 'uint256' },
			{ internalType: 'uint256', name: '_gasPrice', type: 'uint256' }
		],
		name: 'findBestPathWithGas',
		outputs: [
			{
				components: [
					{ internalType: 'uint256[]', name: 'amounts', type: 'uint256[]' },
					{ internalType: 'address[]', name: 'adapters', type: 'address[]' },
					{ internalType: 'address[]', name: 'path', type: 'address[]' },
					{ internalType: 'uint256', name: 'gasEstimate', type: 'uint256' }
				],
				internalType: 'struct YakRouter.FormattedOfferWithGas',
				name: '',
				type: 'tuple'
			}
		],
		stateMutability: 'view',
		type: 'function'
	},
	{
		inputs: [
			{
				components: [
					{ internalType: 'uint256', name: 'amountIn', type: 'uint256' },
					{ internalType: 'uint256', name: 'amountOut', type: 'uint256' },
					{ internalType: 'address[]', name: 'path', type: 'address[]' },
					{ internalType: 'address[]', name: 'adapters', type: 'address[]' }
				],
				internalType: 'struct YakRouter.Trade',
				name: '_trade',
				type: 'tuple'
			},
			{ internalType: 'address', name: '_to', type: 'address' },
			{ internalType: 'uint256', name: '_fee', type: 'uint256' }
		],
		name: 'swapNoSplit',
		outputs: [],
		stateMutability: 'nonpayable',
		type: 'function'
	},
	{
		inputs: [
			{
				components: [
					{ internalType: 'uint256', name: 'amountIn', type: 'uint256' },
					{ internalType: 'uint256', name: 'amountOut', type: 'uint256' },
					{ internalType: 'address[]', name: 'path', type: 'address[]' },
					{ internalType: 'address[]', name: 'adapters', type: 'address[]' }
				],
				internalType: 'struct YakRouter.Trade',
				name: '_trade',
				type: 'tuple'
			},
			{ internalType: 'address', name: '_to', type: 'address' },
			{ internalType: 'uint256', name: '_fee', type: 'uint256' }
		],
		name: 'swapNoSplitFromAVAX',
		outputs: [],
		stateMutability: 'payable',
		type: 'function'
	},
	{
		inputs: [
			{
				components: [
					{ internalType: 'uint256', name: 'amountIn', type: 'uint256' },
					{ internalType: 'uint256', name: 'amountOut', type: 'uint256' },
					{ internalType: 'address[]', name: 'path', type: 'address[]' },
					{ internalType: 'address[]', name: 'adapters', type: 'address[]' }
				],
				internalType: 'struct YakRouter.Trade',
				name: '_trade',
				type: 'tuple'
			},
			{ internalType: 'address', name: '_to', type: 'address' },
			{ internalType: 'uint256', name: '_fee', type: 'uint256' }
		],
		name: 'swapNoSplitToAVAX',
		outputs: [],
		stateMutability: 'nonpayable',
		type: 'function'
	}
];

```

`interface/src/components/Aggregator/adapters/yieldyak/index.ts`:

```ts
import BigNumber from 'bignumber.js';
import { sendTx } from '../../utils/sendTx';
import { ABI } from './abi';
import { encodeFunctionData, zeroAddress } from 'viem';
import { readContract } from 'wagmi/actions';
import { config } from '../../../WalletProvider';
import { chainsMap } from '../../constants';

// Source https://github.com/yieldyak/yak-aggregator
export const chainToId = {
	avax: '0xC4729E56b831d74bBc18797e0e17A295fA77488c',
	canto: '0xE9A2a22c92949d52e963E43174127BEb50739dcF'
};

export const name = 'YieldYak';
export const token = 'YAK';

export function approvalAddress(chain: string) {
	return chainToId[chain];
}

const nativeToken = {
	avax: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',
	canto: '0x826551890dc65655a0aceca109ab11abdbd7a07b'
};

export async function getQuote(chain: string, from: string, to: string, amount: string, extra: any) {
	const tokenFrom = from === zeroAddress ? nativeToken[chain] : from;
	const tokenTo = to === zeroAddress ? nativeToken[chain] : to;

	const gasPrice = extra.gasPriceData?.gasPrice ?? '1062500000000';

	const data = (await readContract(config, {
		address: chainToId[chain],
		abi: ABI,
		functionName: 'findBestPathWithGas',
		args: [amount, tokenFrom, tokenTo, 3, gasPrice],
		chainId: chainsMap[chain]
	})) as {
		amounts: Array<bigint>;
		adapters: Array<`0x${string}`>;
		gasEstimate: bigint;
		path: Array<`0x${string}`>;
	};

	const expectedAmount = data.amounts[data.amounts.length - 1];

	const minAmountOut = BigNumber(expectedAmount.toString())
		.times(1 - Number(extra.slippage) / 100)
		.toFixed(0);

	const gas = data.gasEstimate + 21000n;

	return {
		amountReturned: expectedAmount.toString(),
		estimatedGas: gas.toString(), // Gas estimates only include gas-cost of swapping and querying on adapter and not intermediate logic.
		rawQuote: {
			// convert bigint to string so when we send swap event to our server, app doesn't crash serializing bigint values
			offer: {
				...data,
				amounts: data.amounts.map((amount) => String(amount)),
				gasEstimate: String(data.gasEstimate)
			},
			minAmountOut
		},
		tokenApprovalAddress: chainToId[chain],
		logo: 'https://assets.coingecko.com/coins/images/17654/small/yieldyak.png?1665824438'
	};
}

export async function swap({ chain, fromAddress, rawQuote, from, to }) {
	const data = encodeFunctionData({
		abi: ABI,
		functionName:
			from === zeroAddress ? 'swapNoSplitFromAVAX' : to === zeroAddress ? 'swapNoSplitToAVAX' : 'swapNoSplit',
		args: [
			[rawQuote.offer.amounts[0], rawQuote.minAmountOut, rawQuote.offer.path, rawQuote.offer.adapters],
			fromAddress,
			0
		]
	});

	const tx = {
		to: chainToId[chain],
		data,
		...(from === zeroAddress ? { value: rawQuote.offer.amounts[0] } : {})
	};

	const res = await sendTx(tx);

	return res;
}

```

`interface/src/components/Aggregator/chainToCoingeckoId.ts`:

```ts

// Copied from @defillama/sdk/src/computeTVL/index.ts
export const chainToCoingeckoId = {
  bsc: "binance-smart-chain",
  ethereum: "ethereum",
  polygon: "polygon-pos",
  avax: "avalanche",
  fantom: "fantom",
  xdai: "xdai",
  heco: "huobi-token",
  okexchain: "okex-chain",
  harmony: "harmony-shard-0",
  kcc: "kucoin-community-chain",
  celo: "celo",
  arbitrum: "arbitrum-one",
  iotex: "iotex",
  moonriver: "moonriver",
  solana: "solana",
  terra: "terra",
  tron: "tron",
  waves: "waves",
  klaytn: "klay-token",
  osmosis: "osmosis",
  kava: "kava",
  icon: "icon",
  optimism: "optimistic-ethereum",
  eos: "eos",
  secret: "secret",
  rsk: "rootstock",
  neo: "neo",
  tezos: "tezos",
  wan: "wanchain",
  ontology: "ontology",
  algorand: "algorand",
  zilliqa: "zilliqa",
  kardia: "kardiachain",
  cronos: "cronos",
  aurora: "aurora",
  boba: "boba",
  metis: "metis-andromeda",
  telos: "telos",
  moonbeam: "moonbeam",
  meter: "meter",
  sx: "sx-network",
  velas: "velas",
  milkomeda: "milkomeda-cardano",
  canto: "canto",
}

```

`interface/src/components/Aggregator/claimAbi.ts`:

```ts
export const CLAIM_ABI = [
	{
		inputs: [
			{ internalType: 'contract IERC20VotesUpgradeable', name: '_token', type: 'address' },
			{ internalType: 'address payable', name: '_sweepReceiver', type: 'address' },
			{ internalType: 'address', name: '_owner', type: 'address' },
			{ internalType: 'uint256', name: '_claimPeriodStart', type: 'uint256' },
			{ internalType: 'uint256', name: '_claimPeriodEnd', type: 'uint256' },
			{ internalType: 'address', name: 'delegateTo', type: 'address' }
		],
		stateMutability: 'nonpayable',
		type: 'constructor'
	},
	{
		anonymous: false,
		inputs: [
			{ indexed: true, internalType: 'address', name: 'recipient', type: 'address' },
			{ indexed: false, internalType: 'uint256', name: 'amount', type: 'uint256' }
		],
		name: 'CanClaim',
		type: 'event'
	},
	{
		anonymous: false,
		inputs: [
			{ indexed: true, internalType: 'address', name: 'recipient', type: 'address' },
			{ indexed: false, internalType: 'uint256', name: 'amount', type: 'uint256' }
		],
		name: 'HasClaimed',
		type: 'event'
	},
	{
		anonymous: false,
		inputs: [
			{ indexed: true, internalType: 'address', name: 'previousOwner', type: 'address' },
			{ indexed: true, internalType: 'address', name: 'newOwner', type: 'address' }
		],
		name: 'OwnershipTransferred',
		type: 'event'
	},
	{
		anonymous: false,
		inputs: [{ indexed: true, internalType: 'address', name: 'newSweepReceiver', type: 'address' }],
		name: 'SweepReceiverSet',
		type: 'event'
	},
	{
		anonymous: false,
		inputs: [{ indexed: false, internalType: 'uint256', name: 'amount', type: 'uint256' }],
		name: 'Swept',
		type: 'event'
	},
	{
		anonymous: false,
		inputs: [
			{ indexed: true, internalType: 'address', name: 'recipient', type: 'address' },
			{ indexed: false, internalType: 'uint256', name: 'amount', type: 'uint256' }
		],
		name: 'Withdrawal',
		type: 'event'
	},
	{ inputs: [], name: 'claim', outputs: [], stateMutability: 'nonpayable', type: 'function' },
	{
		inputs: [
			{ internalType: 'address', name: 'delegatee', type: 'address' },
			{ internalType: 'uint256', name: 'expiry', type: 'uint256' },
			{ internalType: 'uint8', name: 'v', type: 'uint8' },
			{ internalType: 'bytes32', name: 'r', type: 'bytes32' },
			{ internalType: 'bytes32', name: 's', type: 'bytes32' }
		],
		name: 'claimAndDelegate',
		outputs: [],
		stateMutability: 'nonpayable',
		type: 'function'
	},
	{
		inputs: [],
		name: 'claimPeriodEnd',
		outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
		stateMutability: 'view',
		type: 'function'
	},
	{
		inputs: [],
		name: 'claimPeriodStart',
		outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
		stateMutability: 'view',
		type: 'function'
	},
	{
		inputs: [{ internalType: 'address', name: '', type: 'address' }],
		name: 'claimableTokens',
		outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
		stateMutability: 'view',
		type: 'function'
	},
	{
		inputs: [],
		name: 'owner',
		outputs: [{ internalType: 'address', name: '', type: 'address' }],
		stateMutability: 'view',
		type: 'function'
	},
	{ inputs: [], name: 'renounceOwnership', outputs: [], stateMutability: 'nonpayable', type: 'function' },
	{
		inputs: [
			{ internalType: 'address[]', name: '_recipients', type: 'address[]' },
			{ internalType: 'uint256[]', name: '_claimableAmount', type: 'uint256[]' }
		],
		name: 'setRecipients',
		outputs: [],
		stateMutability: 'nonpayable',
		type: 'function'
	},
	{
		inputs: [{ internalType: 'address payable', name: '_sweepReceiver', type: 'address' }],
		name: 'setSweepReciever',
		outputs: [],
		stateMutability: 'nonpayable',
		type: 'function'
	},
	{ inputs: [], name: 'sweep', outputs: [], stateMutability: 'nonpayable', type: 'function' },
	{
		inputs: [],
		name: 'sweepReceiver',
		outputs: [{ internalType: 'address payable', name: '', type: 'address' }],
		stateMutability: 'view',
		type: 'function'
	},
	{
		inputs: [],
		name: 'token',
		outputs: [{ internalType: 'contract IERC20VotesUpgradeable', name: '', type: 'address' }],
		stateMutability: 'view',
		type: 'function'
	},
	{
		inputs: [],
		name: 'totalClaimable',
		outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
		stateMutability: 'view',
		type: 'function'
	},
	{
		inputs: [{ internalType: 'address', name: 'newOwner', type: 'address' }],
		name: 'transferOwnership',
		outputs: [],
		stateMutability: 'nonpayable',
		type: 'function'
	},
	{
		inputs: [{ internalType: 'uint256', name: 'amount', type: 'uint256' }],
		name: 'withdraw',
		outputs: [],
		stateMutability: 'nonpayable',
		type: 'function'
	}
];

```

`interface/src/components/Aggregator/constants.ts`:

```ts
import { zeroAddress } from 'viem';

export const defillamaReferrerAddress = '0x08a3c2A819E3de7ACa384c798269B3Ce1CD0e437';
export const altReferralAddress = '0xa43C3EDe995AA058B68B882c6aF16863F18c5330';

export const chainsMap = {
	ethereum: 1,
	bsc: 56,
	polygon: 137,
	optimism: 10,
	arbitrum: 42161,
	avax: 43114,
	gnosis: 100,
	fantom: 250,
	klaytn: 8217,
	aurora: 1313161554,
	celo: 42220,
	cronos: 25,
	dogechain: 2000,
	moonriver: 1285,
	bttc: 199,
	oasis: 42262,
	velas: 106,
	heco: 128,
	harmony: 1666600000,
	boba: 288,
	okexchain: 66,
	fuse: 122,
	moonbeam: 1284,
	canto: 7700,
	zksync: 324,
	polygonzkevm: 1101,
	ontology: 58,
	kava: 2222,
	pulse: 369,
	metis: 1088,
	base: 8453,
	linea: 59144,
	mode: 34443,
	mantle: 5000,
	scroll: 534352,
	sonic: 146
} as const;

export const geckoChainsMap: Record<string, number> = {
	ethereum: 1,
	'binance-smart-chain': 56,
	'polygon-pos': 137,
	'optimistic-ethereum': 10,
	'arbitrum-one': 42161,
	avalanche: 43114,
	xdai: 100,
	fantom: 250,
	'klay-token': 8217,
	aurora: 1313161554,
	celo: 42220,
	cronos: 25,
	dogechain: 2000,
	moonriver: 1285,
	bittorrent: 199,
	oasis: 42262,
	velas: 106,
	heco: 128,
	'harmony-shard-0': 1666600000,
	boba: 288,
	'okex-chain': 66,
	fuse: 122,
	moonbeam: 1284,
	canto: 7700,
	'polygon-zkevm': 1101,
	zksync: 324,
	pulsechain: 369,
	kava: 2222,
	ontology: 58,
	'metis-andromeda': 1088,
	linea: 59144,
	base: 8453,
	mode: 34443,
	mantle: 5000,
	scroll: 534352,
	sonic: 146
};

export const chainGasToken: Record<keyof typeof chainsMap, string> = {
	ethereum: 'ethereum',
	bsc: 'binancecoin',
	polygon: 'matic-network',
	optimism: 'ethereum',
	arbitrum: 'ethereum',
	avax: 'avalanche-2',
	gnosis: 'xdai',
	fantom: 'fantom',
	klaytn: 'klay-token',
	aurora: 'ethereum',
	celo: 'celo',
	cronos: 'crypto-com-chain',
	dogechain: 'dogecoin',
	moonriver: 'moonriver',
	bttc: 'bittorrent',
	oasis: 'oasis-network',
	velas: 'velas',
	heco: 'huobi-token',
	harmony: 'harmony',
	boba: 'ethereum',
	okexchain: 'oec-token',
	fuse: 'fuse-network-token',
	moonbeam: 'moonbeam',
	canto: 'canto',
	zksync: 'ethereum',
	polygonzkevm: 'ethereum',
	ontology: 'ontology',
	kava: 'kava',
	pulse: 'pulsechain',
	metis: 'metis-token',
	base: 'ethereum',
	linea: 'ethereum',
	mode: 'ethereum',
	mantle: 'mantle',
	scroll: 'ethereum',
	sonic: 'sonic'
};

export const geckoTerminalChainsMap = {
	1: 'eth',
	56: 'bsc',
	137: 'polygon_pos',
	10: 'optimism',
	42161: 'arbitrum',
	43114: 'avax',
	100: 'gnosis',
	250: 'ftm',
	1313161554: 'aurora',
	42220: 'celo',
	25: 'cro',
	2000: 'dogechain',
	1285: 'movr',
	42262: 'oasis',
	106: 'velas',
	128: 'heco',
	1666600000: 'one',
	288: 'boba',
	66: 'okexchain',
	122: 'fuse',
	1284: 'glmr',
	199: 'bttc',
	8217: 'klaytn',
	7700: 'canto',
	2222: 'kava',
	369: 'pulsechain',
	1101: 'polygon-zkevm',
	324: 'zksync',
	1088: 'metis',
	8453: 'base',
	59144: 'linea'
};

export const chainIdToName = (chainId) => {
	return Object.entries(chainsMap).find(([, id]) => String(id) === String(chainId))?.[0];
};

export const chainNamesReplaced = {
	bsc: 'BSC',
	avax: 'Avalanche',
	okexchain: 'OKTChain',
	bttc: 'BitTorrent'
};

export const nativeAddress = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'.toLowerCase();

export const initialLiquidity = [500, 1_000, 10_000, 100_000, 1_000_000, 10_000_000, 100_000_000, 500_000_000];

export const WETH = {
	ethereum: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'.toLowerCase()
};
export const PRICE_IMPACT_MEDIUM_THRESHOLD = 5;
export const PRICE_IMPACT_HIGH_THRESHOLD = 10;
export const PRICE_IMPACT_WARNING_THRESHOLD = 3;

export const tokenApprovalAbi = [
	{
		constant: false,
		inputs: [
			{ name: '_spender', type: 'address' },
			{ name: '_value', type: 'uint256' }
		],
		name: 'approve',
		outputs: [],
		payable: false,
		stateMutability: 'nonpayable',
		type: 'function'
	}
] as const;

export const wrappedTokensByChain = {
	1: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // Ethereum: WETH
	56: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // BSC: WBNB
	137: '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // Polygon: WPOL
	10: '0x4200000000000000000000000000000000000006', // Optimism: WETH
	42161: '0x82af49447d8a07e3bd95bd0d56f35241523fbab1', // Arbitrum: WETH
	43114: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // Avalanche: WAVAX
	100: '0xe91d153e0b41518a2ce8dd3d7944fa863463a97d', // Gnosis: WXDAI
	250: '0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83', // Fantom: WFTM
	8217: '0x19aac5f612f524b754ca7e7c41cbfa2e981a4432', // Klaytn: WKLAY
	1313161554: null, // Aurora
	42220: '0x2021B12D8138e2D63cF0895eccABC0DFc92416c6', // Celo: WCELO
	25: null, // Cronos
	2000: null, // Dogechain
	1285: '0x98878b06940ae243284ca214f92bb71a2b032b8a', // Moonriver: WMOVR
	199: '0x23181f21dea5936e24163ffaba4ea3b316b57f3c', // BitTorrent: WBTT
	106: null, // Velas
	128: null, // Heco
	1666600000: '0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a', // Harmony: WONE
	288: '0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000', // Boba: WETH
	66: '0x8F8526dbfd6E38E3D8307702cA8469Bae6C56C15', // OKX: WOKT
	122: '0x0BE9e53fd7EDaC9F859882AfdDa116645287C629', // Fuse: WFUSE
	1284: '0xacc15dc74880c9944775448304b263d191c6077f', // Moonbeam: WGLMR
	7700: '0x826551890dc65655a0aceca109ab11abdbd7a07b', // Canto: WCANTO
	324: '0xf00DAD97284D0c6F06dc4Db3c32454D4292c6813', // zkSync: WETH
	1101: '0x4F9A0e7FD2Bf6067db6994CF12E4495Df938E6e9', // Polygon zkEVM: WETH
	58: '0x219cc8e994ea6b35cdcffb5d44e229325d5ad02a', // Ontology: WONT
	2222: '0xc86c7C0eFbd6A49B35E8714C5f59D99De09A225b', // Kava: WKAVA
	369: '0xA1077a294dDE1B09bB078844df40758a5D0f9a27', // PulseChain: WPLS
	1088: '0x75cb093E4D61d2A2e65D8e0BBb01DE8d89b53481', // Metis: WMETIS
	8453: '0x4200000000000000000000000000000000000006', // Base: WETH
	59144: '0xe5d7c2a44ffddf6b295a15c148167daaaf5cf34f', // Linea: WETH
	34443: '0x4200000000000000000000000000000000000006', // Mode: WETH
	5000: '0x78c1b0c915c4faa5fffa6cabf0219da63d7f4cb8', // Mantle: WMNT
	534352: '0x5300000000000000000000000000000000000004', // Scroll: WETH
	146: '0x039e2fb66102314ce7b64ce5ce3e5183bc94ad38' // Sonic: wS
} as const;

export const topTokensByChain = {
	1: [
		zeroAddress, // ETH
		'0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC
		'0xdac17f958d2ee523a2206206994597c13d831ec7', // USDT
		'0x2260fac5e5542a773aa44fbcfedf7c193bc2c599', // WBTC
		'0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2' // WETH
	],
	56: [
		zeroAddress, // BNB
		'0x55d398326f99059ff775485246999027b3197955', // USDT
		'0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d', // USDC
		'0x2170ed0880ac9a755fd29b2688956bd959f933f8' // ETH
	],
	137: [
		zeroAddress, // POL
		'0x3c499c542cef5e3811e1192ce70d8cc03d5c3359', // USDC
		'0xc2132d05d31c914a87c6611c10748aeb04b58e8f', // USDT
		'0x7ceb23fd6bc0add59e62ac25578270cff1b9f619' // WETH
	],
	10: [
		zeroAddress, // ETH
		'0x0b2c639c533813f4aa9d7837caf62653d097ff85', // USDC
		'0x94b008aa00579c1307b0ef2c499ad98a8ce58e58', // USDT
		'0x4200000000000000000000000000000000000042' // OP
	],
	42161: [
		zeroAddress, // ETH
		'0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9', // USDT
		'0xaf88d065e77c8cc2239327c5edb3a432268e5831', // USDC
		'0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f' // WBTC
	],
	43114: [
		zeroAddress, // AVAX
		'0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7', // USDT
		'0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e', // USDC
		'0x152b9d0FdC40C096757F570A51E494bd4b943E50' // BTC.b
	],
	100: [
		zeroAddress, // XDAI
		'0x4ecaba5870353805a9f068101a40e0f32ed605c6', // USDT
		'0xddafbb505ad214d7b80b1f830fccc89b60fb7a83', // USDC
		'0x6a023ccd1ff6f2045c3309768ead9e68f978f6e1' // WETH
	],
	250: [],
	8217: [],
	1313161554: [],
	42220: [],
	25: [],
	2000: [],
	1285: [],
	199: [],
	106: [],
	128: [],
	1666600000: [],
	288: [],
	66: [],
	122: [],
	1284: [],
	7700: [],
	324: [
		'0x000000000000000000000000000000000000800A', // ETH
		'0x1d17CBcF0D6D143135aE902365D2E5e2A16538D4', // USDC
		'0x5A7d6b2F92C77FAD6CCaBd7EE0624E64907Eaf3E' // ZK
	],
	1101: [
		zeroAddress, // ETH
		'0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035', // USDC
		'0x1e4a5963abfd975d8c9021ce480b42188849d41d', // USDT
		'0x22b21beddef74fe62f031d2c5c8f7a9f8a4b304d' // POL
	],
	58: [],
	2222: [],
	369: [],
	1088: [],
	8453: [
		zeroAddress, // ETH
		'0x833589fcd6edb6e08f4c7c32d4f71b54bda02913', // USDC
		'0x820c137fa70c8691f0e44dc420a5e53c168921dc', // USDS
		'0xcbb7c0000ab88b473b1f5afd9ef808440eed33bf' // cbBTC
	],
	59144: [
		zeroAddress, // ETH
		'0xa219439258ca9da29e9cc4ce5596924745e12b93', // USDT
		'0x176211869ca2b568f2a7d4ee941e073a821ee1ff', // USDC
		'0x3aab2285ddcddad8edf438c1bab47e1a9d05a9b4' // WBTC
	],
	34443: [],
	5000: [],
	534352: [
		zeroAddress, // ETH
		'0xf55bec9cafdbe8730f096aa55dad6d22d44099df', // USDT
		'0x06efdbff2a14a7c8e15944d1f4a48f9f95f663a4', // USDC
		'0x3c1bca5a656e69edcd0d4e36bebb3fcdaca60cf1', // WBTC
		'0x5300000000000000000000000000000000000004' // WETH
	],
	146: [
		zeroAddress, // S
		'0x29219dd400f2bf60e5a23d13be72b486d4038894', // USDC.e
		'0x039e2fb66102314ce7b64ce5ce3e5183bc94ad38', // wS
		'0x50c42deacd8fc9773493ed674b675be577f2634b' // WETH
	]
};

```

`interface/src/components/Aggregator/hooks/index.ts`:

```ts
import { useTokenApprove } from './useTokenApprove'

export { useTokenApprove }

```

`interface/src/components/Aggregator/hooks/useEstimateGas.ts`:

```ts
import { useQueries, UseQueryOptions } from '@tanstack/react-query';
import BigNumber from 'bignumber.js';
import { encodeFunctionData, maxInt256, zeroAddress } from 'viem';
import { IRoute } from '~/queries/useGetRoutes';
import { chainsMap, tokenApprovalAbi } from '../constants';
import { useMemo } from 'react';

const traceRpcs = {
	// https://docs.blastapi.io/blast-documentation/trace-api
	ethereum: 'https://eth-mainnet.blastapi.io/090c6ffd-6cd1-40d1-98af-338a96523ea1',
	bsc: 'https://bsc-mainnet.blastapi.io/090c6ffd-6cd1-40d1-98af-338a96523ea1',
	gnosis: 'https://gnosis-mainnet.blastapi.io/090c6ffd-6cd1-40d1-98af-338a96523ea1',
	moonbeam: 'https://moonbeam.blastapi.io/090c6ffd-6cd1-40d1-98af-338a96523ea1',
	moonriver: 'https://moonriver.blastapi.io/090c6ffd-6cd1-40d1-98af-338a96523ea1',
	//palm: 'https://palm-mainnet.blastapi.io/090c6ffd-6cd1-40d1-98af-338a96523ea1', // we don't support it
	polygon: 'https://polygon-mainnet.blastapi.io/090c6ffd-6cd1-40d1-98af-338a96523ea1',
	//arbitrum: 'https://arbitrum-one.blastapi.io/090c6ffd-6cd1-40d1-98af-338a96523ea1'
};

export const estimateGas = async ({
	route,
	token,
	userAddress,
	chain,
	balance
}: {
	route: IRoute;
	token?: string;
	userAddress?: string;
	chain?: string;
	balance?: number | null;
}) => {
	if (
		!token ||
		!userAddress ||
		!chain ||
		!balance ||
		!Number.isFinite(balance) ||
		balance < +route.fromAmount ||
		!route.price ||
		!traceRpcs[chain] || route.name === 'Matcha/0x v2'
	) {
		return null;
	}

	try {
		const tx = route?.tx;
		const isNative = token === zeroAddress;

		try {
			const approveTx = isNative
				? null
				: {
						to: token,
						data: encodeFunctionData({
							abi: tokenApprovalAbi,
							functionName: 'approve',
							args: [route.price.tokenApprovalAddress, maxInt256]
						})
					};

			const resetApproveTx = isNative
				? null
				: {
						to: token,
						data: encodeFunctionData({
							abi: tokenApprovalAbi,
							functionName: 'approve',
							args: [route.price.tokenApprovalAddress, 0n]
						})
					};

			const callParams = [resetApproveTx, approveTx, tx].filter(Boolean).map((txData) => [
				{
					from: userAddress,
					to: txData!.to,
					data: txData!.data,
					...(isNative ? { value: '0x' + BigNumber(route.fromAmount).toString(16) } : {})
				},
				['trace']
			]);

			const response = await fetch(traceRpcs[chain], {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					id: chainsMap[chain],
					jsonrpc: '2.0',
					method: chain === 'arbitrum' ? 'arbtrace_callMany' : 'trace_callMany',
					params: [callParams, 'latest']
				})
			}).then((res) => res.json());

			if (response.error) {
				console.log(response.error);
				return null;
			}

			const swapTx = response.result[response.result.length - 1];

			if (!swapTx) return null;

			return {
				gas: (Number(swapTx.trace[0].result?.gasUsed ?? '0x0') + 21e3).toString(), // ignores calldata and accesslist costs
				isFailed: swapTx.trace[0]?.error?.includes('Revert') ?? false,
				aggGas: route.price?.estimatedGas,
				name: route.name
			};
		} catch (e) {
			console.log(e);
			return null;
		}
	} catch (ee) {
		console.log('[ESTIMATE GAS]', ee);
		throw new Error(`Failed to estimate gas of ${route.name}`);
	}
};

type EstimationRes = Awaited<ReturnType<typeof estimateGas>>;

export const useEstimateGas = ({
	routes,
	token,
	userAddress,
	chain,
	balance,
	isOutput
}: {
	routes: Array<IRoute>;
	token?: string;
	userAddress?: string;
	chain?: string;
	balance?: number | null;
	isOutput: boolean;
}) => {
	const res = useQueries({
		queries: routes
			.filter((route) => !!route?.tx?.to)
			.map<UseQueryOptions<Awaited<ReturnType<typeof estimateGas>>>>((route) => {
				return {
					queryKey: ['estimateGas', route.name, chain, route?.tx?.data, balance],
					queryFn: () => estimateGas({ route, token, userAddress, chain, balance })
				};
			})
	});

	const data = useMemo(() => {
		return (
			res
				?.filter((r) => r.status === 'success' && !!r.data && r.data.gas)
				.reduce(
					(acc, r: any) => ({
						...acc,
						[r.data.name]: r.data
					}),
					{} as Record<string, EstimationRes>
				) ?? {}
		);
	}, [res]);

	return {
		isLoading: res.some((r) => r.status === 'pending') || (chain && traceRpcs[chain] === undefined),
		data
	};
};

```

`interface/src/components/Aggregator/hooks/useTokenApprove.ts`:

```ts
import { useAccount, useEstimateGas } from 'wagmi';
import { chainsMap, nativeAddress, tokenApprovalAbi } from '../constants';
import { useMutation, useQuery } from '@tanstack/react-query';
import { zeroAddress, maxInt256, encodeFunctionData } from 'viem';
import { arbitrum, fantom } from 'viem/chains';
import { waitForTransactionReceipt, writeContract } from 'wagmi/actions';
import { config } from '~/components/WalletProvider';
import { getAllowance, oldErc } from '../utils/getAllowance';

const chainsWithDefaultGasLimit = {
	[fantom.id]: true,
	[arbitrum.id]: true
};

async function approveTokenSpend({
	address,
	chain,
	spender,
	amount,
	customGasLimit
}: {
	address?: `0x${string}`;
	chain?: string;
	spender?: `0x${string}`;
	amount: bigint;
	customGasLimit?: { gas: bigint } | null;
}) {
	try {
		if (!address || !spender || !chain) {
			throw new Error('Invalid arguments');
		}

		const hash = await writeContract(config, {
			address,
			abi: tokenApprovalAbi,
			functionName: 'approve',
			args: [spender, amount],
			chainId: chainsMap[chain],
			...(customGasLimit ?? {})
		});

		const receipt = await waitForTransactionReceipt(config, { hash, chainId: chainsMap[chain] });

		return receipt;
	} catch (error) {
		throw new Error(`[TOKEN-APPROVAL]: ${error instanceof Error ? error.message : 'Failed to approve token'}`);
	}
}

const useApproveTokenSpend = () => {
	return useMutation({ mutationFn: approveTokenSpend });
};

const useGetAllowance = ({
	token,
	spender,
	amount,
	chain
}: {
	token?: `0x${string}`;
	spender?: `0x${string}`;
	amount?: string;
	chain?: string;
}) => {
	const { address } = useAccount();

	const isOld = token ? oldErc.includes(token.toLowerCase()) : false;

	const {
		data: allowance,
		refetch,
		isLoading,
		error: errorFetchingAllowance
	} = useQuery({
		queryKey: ['token-allowance', address, token, chain, spender],
		queryFn: () =>
			getAllowance({
				token,
				chain,
				address,
				spender
			}),
		retry: 2
	});

	const shouldRemoveApproval =
		isOld && allowance && amount && !Number.isNaN(Number(amount)) && allowance < BigInt(amount) && allowance !== 0n;

	return { allowance, shouldRemoveApproval, refetch, isLoading, errorFetchingAllowance };
};

export const useTokenApprove = ({
	token,
	spender,
	amount,
	chain
}: {
	token?: `0x${string}`;
	spender?: `0x${string}`;
	amount?: string;
	chain?: string;
}) => {
	const { address, isConnected } = useAccount();

	const {
		allowance,
		shouldRemoveApproval,
		refetch,
		isLoading: isFetchingAllowance,
		errorFetchingAllowance
	} = useGetAllowance({
		token,
		spender,
		amount,
		chain
	});

	const normalizedAmount = !Number.isNaN(Number(amount)) ? amount : '0';

	const encodedFunctionData =
		isConnected && !!spender && !!token && normalizedAmount !== '0'
			? encodeFunctionData({
					abi: tokenApprovalAbi,
					functionName: 'approve',
					args: spender && [spender, normalizedAmount ? BigInt(normalizedAmount) : maxInt256]
				})
			: null;

	const { data: gasLimit } = useEstimateGas({
		to: token,
		data: encodedFunctionData!,
		chainId: chain && chainsMap[chain],
		query: {
			enabled: encodedFunctionData ? true : false
		}
	});

	const customGasLimit =
		shouldRemoveApproval || gasLimit === undefined || !chain || chainsWithDefaultGasLimit[chainsMap[chain]]
			? null
			: { gas: (gasLimit * 140n) / 100n };

	const { mutateAsync: approveWriteContract, isPending: isLoading } = useApproveTokenSpend();
	const approve = () => {
		approveWriteContract({
			address: token,
			spender,
			amount: normalizedAmount ? BigInt(normalizedAmount) : maxInt256,
			chain,
			customGasLimit
		})
			.then(() => {
				refetch();
			})
			.catch((err) => console.log(err));
	};

	const { mutateAsync: approveInfiniteWriteContract, isPending: isInfiniteLoading } = useApproveTokenSpend();
	const approveInfinite = () => {
		approveInfiniteWriteContract({
			address: token,
			spender,
			amount: maxInt256,
			chain,
			customGasLimit
		})
			.then(() => {
				refetch();
			})
			.catch((err) => console.log(err));
	};

	const { mutateAsync: approveResetWriteContract, isPending: isResetLoading } = useApproveTokenSpend();
	const approveReset = () => {
		approveResetWriteContract({
			address: token,
			spender,
			amount: 0n,
			chain,
			customGasLimit
		})
			.then(() => {
				refetch();
			})
			.catch((err) => console.log(err));
	};

	if (token === zeroAddress || token?.toLowerCase() === nativeAddress.toLowerCase()) return { isApproved: true };

	if (!address || (!allowance && allowance !== 0n)) return { isApproved: false, errorFetchingAllowance };

	if (allowance === maxInt256) return { isApproved: true, allowance };

	if (normalizedAmount && allowance >= BigInt(normalizedAmount)) return { isApproved: true, allowance };

	return {
		isApproved: false,
		approve,
		approveInfinite,
		approveReset,
		isLoading: isFetchingAllowance || isLoading,
		isConfirmingApproval: isLoading,
		isInfiniteLoading: isInfiniteLoading,
		isConfirmingInfiniteApproval: isInfiniteLoading,
		isResetLoading: isResetLoading,
		isConfirmingResetApproval: isResetLoading,
		allowance,
		shouldRemoveApproval,
		refetch
	};
};

```

`interface/src/components/Aggregator/list.ts`:

```ts
import * as matcha from './adapters/0x';
import * as inch from './adapters/1inch';
import * as cowswap from './adapters/cowswap';
//import * as firebird from './adapters/firebird';
import * as kyberswap from './adapters/kyberswap';
//import * as hashflow from './adapters/hashflow';
//import * as openocean from './adapters/openocean';
import * as paraswap from './adapters/paraswap';
// import * as lifi from './adapters/lifi';
// import * as rango from './adapters/rango';

// import * as unidex from "./adapters/unidex" - disabled, their api is broken
// import * as airswap from './adapters/airswap' cors
import * as odos from './adapters/odos';
// import * as yieldyak from './adapters/yieldyak';
// import * as llamazip from './adapters/llamazip';
// import * as krystal from './adapters/krystal'
import * as matchaGasless from './adapters/0xGasless';
import * as matchaV2 from './adapters/0xV2';

export const adapters = [matcha, cowswap, paraswap, kyberswap, inch, matchaGasless, odos, matchaV2];

export const inifiniteApprovalAllowed = [matcha.name, cowswap.name, matchaGasless.name];

export const adaptersWithApiKeys = {
	[matcha.name]: true,
	[matchaGasless.name]: true,
	[matchaV2.name]: true,
	[inch.name]: true,
	//[hashflow.name]: true
};

```

`interface/src/components/Aggregator/nativeTokens.ts`:

```ts
import { zeroAddress } from 'viem';

const ICONS_CDN = 'https://icons.llamao.fi/icons';
export function chainIconUrl(chain) {
	return `${ICONS_CDN}/chains/rsz_${chain.toLowerCase()}?w=48&h=48`;
}

const ethereum = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const binance = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 56,
	name: 'Binance',
	symbol: 'BNB',
	logoURI: chainIconUrl('binance'),
	decimals: 18
};

const arbitrum = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 42161,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const optimism = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 10,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const base = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 8453,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const linea = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 59144,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const scroll = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 534352,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};

const okx = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 66,
	name: 'OKX',
	symbol: 'OKX',
	logoURI: chainIconUrl('okexchain'),
	decimals: 18
};

const boba = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 288,
	logoURI: chainIconUrl('ethereum'),
	name: 'Ethereum',
	symbol: 'ETH',
	decimals: 18
};

const harmony = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1666600000,
	logoURI: chainIconUrl('harmony'),
	decimals: 18,
	name: 'Harmony',
	symbol: 'ONE'
};

const heco = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 128,
	logoURI: chainIconUrl('heco'),
	name: 'Huobi Token',
	symbol: 'HT',
	decimals: 18
};

const velas = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 106,
	logoURI: chainIconUrl('velas'),
	name: 'Velas',
	symbol: 'VLX',
	decimals: 18
};

const oasis = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 24462,
	name: 'Oasis',
	symbol: 'ROSE',
	logoURI: chainIconUrl('oasis'),
	decimals: 18
};

const bttc = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 199,
	name: 'BitTorrent',
	logoURI: chainIconUrl('bittorrent'),
	symbol: 'BTT',
	decimals: 18
};

const moonriver = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1285,
	name: 'MoonRiver',
	logoURI: chainIconUrl('moonriver'),
	symbol: 'MOVR',
	decimals: 18
};

const moonbeam = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1284,
	name: 'Moonbeam',
	logoURI: chainIconUrl('moonbeam'),
	symbol: 'GLMR',
	decimals: 18
};

const fuse = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 122,
	name: 'Fuse',
	logoURI: chainIconUrl('fuse'),
	symbol: 'FUSE',
	decimals: 18
};

const dogechain = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 2000,
	name: 'Doge',
	symbol: 'DOGE',
	decimals: 18,
	logoURI: chainIconUrl('dogechain')
};

const cronos = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 25,
	name: 'Cronos',
	symbol: 'CRO',
	logoURI: chainIconUrl('cronos'),
	decimals: 18
};
const celo = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 42220,
	name: 'Celo',
	symbol: 'CELO',
	logoURI: chainIconUrl('celo'),
	decimals: 18
};
const aurora = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1313161554,
	name: 'Ethereum',
	symbol: 'ETH',
	logoURI: chainIconUrl('ethereum'),
	decimals: 18
};
const avax = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 43114,
	logoURI: chainIconUrl('avax'),
	name: 'Avalanche',
	symbol: 'AVAX',
	decimals: 18
};

const klaytn = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 8217,
	name: 'Klaytn',
	symbol: 'KLAY',
	logoURI: chainIconUrl('klaytn'),
	decimals: 18
};
const fantom = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 250,
	logoURI: chainIconUrl('fantom'),
	name: 'Fantom',
	symbol: 'FTM',
	decimals: 18
};

const gnosis = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 100,
	name: 'xDai',
	symbol: 'xDai',
	logoURI: chainIconUrl('gnosis'),
	decimals: 18
};
const polygon = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 137,
	name: 'Polygon',
	symbol: 'POL',
	logoURI: chainIconUrl('polygon'),
	decimals: 18
};

const canto = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 7700,
	name: 'Canto',
	symbol: 'CANTO',
	logoURI: chainIconUrl('canto'),
	decimals: 18
};

const metis = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1088,
	name: 'Metis',
	symbol: 'METIS',
	logoURI: chainIconUrl('metis'),
	decimals: 18
};

const polygonzkevm = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 1101,
	name: 'Polygon zkEVM',
	symbol: 'ETH',
	logoURI: chainIconUrl('polygon zkevm'),
	decimals: 18
};

const kava = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 2222,
	name: 'Kava',
	symbol: 'KAVA',
	logoURI: chainIconUrl('kava'),
	decimals: 18
};

const zksync = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 324,
	name: 'zkSync Era',
	symbol: 'ETH',
	logoURI: chainIconUrl('zksync era'),
	decimals: 18
};

const ontology = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 58,
	name: 'Ontology',
	symbol: 'ONT',
	logoURI: chainIconUrl('ontologyevm'),
	decimals: 18
};

const pulse = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 369,
	name: 'Pulse',
	symbol: 'PLS',
	logoURI: chainIconUrl('pulse'),
	decimals: 18
};

const sonic = {
	mcap: Number.MAX_SAFE_INTEGER,
	address: zeroAddress,
	chainId: 146,
	name: 'SONIC',
	symbol: 's',
	logoURI: chainIconUrl('sonic'),
	decimals: 18
};

export const nativeTokens = [
	ethereum,
	arbitrum,
	binance,
	optimism,
	polygon,
	oasis,
	fantom,
	velas,
	harmony,
	gnosis,
	klaytn,
	avax,
	aurora,
	cronos,
	celo,
	dogechain,
	moonriver,
	bttc,
	heco,
	boba,
	okx,
	moonbeam,
	fuse,
	canto,
	metis,
	polygonzkevm,
	kava,
	zksync,
	ontology,
	pulse,
	base,
	linea,
	scroll,
	sonic
];

```

`interface/src/components/Aggregator/router.ts`:

```ts
import { allChains } from '../WalletProvider/chains';
import { chainNamesReplaced } from './constants';
import { adapters } from './list';

export const adaptersNames = adapters.map(({ name }) => name);

const adaptersMap = adapters.reduce((acc, adapter) => ({ ...acc, [adapter.name]: adapter }), {});

export function getAllChains() {
	const chains = new Set<string>();
	for (const adapter of adapters) {
		Object.keys(adapter.chainToId).forEach((chain) => chains.add(chain));
	}

	const chainsOptions = allChains
		.map((c) => {
			const isVisible = chains.has(c.network);
			if (!isVisible) return null;
			return {
				value: c.network,
				label: chainNamesReplaced[c.network] ?? c.name,
				chainId: c.id,
				logoURI: c?.iconUrl
			};
		})
		.filter(Boolean);
	return chainsOptions as Array<{
		value: string;
		label: string;
		chainId: number;
		logoURI?: string | null;
	}>;
}

export async function swap({
	chain,
	from,
	to,
	amount,
	fromAddress,
	slippage = '1',
	adapter,
	rawQuote,
	tokens,
	approvalData,
	signature
}) {
	const aggregator = adaptersMap[adapter];

	try {
		const res = await aggregator.swap({
			chain,
			from,
			to,
			amount,
			fromAddress,
			slippage,
			rawQuote,
			tokens,
			approvalData,
			signature
		});
		return res;
	} catch (e) {
		throw e;
	}
}
export async function gaslessApprove({ adapter, rawQuote, isInfiniteApproval }) {
	const aggregator = adaptersMap[adapter];

	if (!aggregator.gaslessApprove) return;

	try {
		const res = await aggregator.gaslessApprove({
			rawQuote,
			isInfiniteApproval
		});
		return res;
	} catch (e) {
		throw e;
	}
}

export async function signatureForSwap({ signTypedDataAsync, adapter, rawQuote }) {
	const aggregator = adaptersMap[adapter];

	if (!aggregator.signatureForSwap) return;

	try {
		const res = await aggregator.signatureForSwap({
			signTypedDataAsync,
			rawQuote
		});
		return res;
	} catch (e) {
		throw e;
	}
}

```

`interface/src/components/Aggregator/rpcs.ts`:

```ts
import { uniq } from 'lodash';
import { fallback, http } from 'wagmi';


const getLlamaRpc = (chain:string) => `https://rpc.llama-rpc.com/${chain}?source=llamaswap`

export const rpcUrls: Record<number, Array<string>> = {
	1: [
		getLlamaRpc("ethereum"),
		'https://cloudflare-eth.com',
		'https://rpc.flashbots.net',
		'https://rpc.builder0x69.io',
		'https://ethereum.publicnode.com',
		'https://eth-mainnet.public.blastapi.io'
	],
	56: [
		getLlamaRpc("bsc"),
		'https://bsc-dataseed.binance.org',
		'https://bsc-dataseed1.defibit.io',
		'https://bsc-dataseed1.ninicoin.io',
		'https://bsc-dataseed2.defibit.io',
		'https://bsc-dataseed2.ninicoin.io'
	],
	137: [
		getLlamaRpc("polygon"),
		'https://rpc-mainnet.matic.quiknode.pro',
		'https://polygon-rpc.com',
		'https://polygon-bor-rpc.publicnode.com',
		'https://endpoints.omniatech.io/v1/matic/mainnet/public'
	],
	128: [getLlamaRpc("heco"), 'https://http-mainnet.hecochain.com'],
	250: [getLlamaRpc("fantom"), 'https://rpcapi.fantom.network', 'https://rpc2.fantom.network', 'https://fantom-rpc.publicnode.com'],
	30: [getLlamaRpc("rsk"), 'https://public-node.rsk.co'],
	88: [getLlamaRpc("tomochain"), 'https://rpc.tomochain.com'],
	100: [getLlamaRpc("xdai"), 'https://rpc.gnosischain.com', 'https://gnosis-mainnet.public.blastapi.io'],
	43114: [
		getLlamaRpc("avax"),
		'https://api.avax.network/ext/bc/C/rpc',
		'https://ava-mainnet.public.blastapi.io/ext/bc/C/rpc',
		'https://endpoints.omniatech.io/v1/avax/mainnet/public'
	],
	888: [getLlamaRpc("wan"), 'https://gwan-ssl.wandevs.org:56891'],
	1666600000: [
		getLlamaRpc("harmony"),
		'https://harmony-0-rpc.gateway.pokt.network',
		'https://api.harmony.one',
		'https://api.s0.t.hmny.io',
		'https://harmony-mainnet.chainstacklabs.com'
	],
	108: [getLlamaRpc("thundercore"), 'https://mainnet-rpc.thundercore.com'],
	66: [getLlamaRpc("okexchain"), 'https://exchainrpc.okex.org'],
	10: [
		getLlamaRpc("optimism"),
		'https://mainnet.optimism.io',
		'https://optimism-mainnet.public.blastapi.io',
		'https://endpoints.omniatech.io/v1/op/mainnet/public'
	],
	42161: [
		getLlamaRpc("arbitrum"),
		'https://arb1.arbitrum.io/rpc',
		'https://arbitrum-one.public.blastapi.io',
		'https://arb1.lava.build'
	],
	321: [getLlamaRpc("kcc"), 'https://rpc-mainnet.kcc.network'],
	42220: [getLlamaRpc("celo"), 'https://forno.celo.org'],
	4689: [getLlamaRpc("iotex"), 'https://babel-api.mainnet.iotex.io'],
	1285: [getLlamaRpc("moonriver"), 'https://rpc.api.moonriver.moonbeam.network', 'https://moonriver.api.onfinality.io/public'],
	336: [
		getLlamaRpc("shiden"),
		'https://shiden.api.onfinality.io/public',
		'https://rpc.shiden.astar.network:8545'
	],
	11297108109: [getLlamaRpc("palm"), 'https://palm-mainnet.infura.io/v3/3a961d6501e54add9a41aa53f15de99b'],
	246: [getLlamaRpc("energyweb"), 'https://rpc.energyweb.org'],
	39797: [getLlamaRpc("energi"), 'https://nodeapi.energi.network'],
	19: [getLlamaRpc("songbird"), 'https://songbird.towolabs.com/rpc'],
	269: [getLlamaRpc("hpb"), 'https://hpbnode.com'],
	60: [getLlamaRpc("gochain"), 'https://rpc.gochain.io'],
	61: [getLlamaRpc("ethereumclassic"), 'https://www.ethercluster.com/etc', 'https://blockscout.com/etc/mainnet/api/eth-rpc'],
	200: [getLlamaRpc("xdaiarb"), 'https://arbitrum.xdaichain.com'],
	24: [getLlamaRpc("kardia"), 'https://rpc.kardiachain.io'],
	122: [getLlamaRpc("fuse"), 'https://rpc.fuse.io'],
	10000: [getLlamaRpc("smartbch"), 'https://smartbch.fountainhead.cash/mainnet'],
	20: [getLlamaRpc("elastos"), 'https://api.elastos.io/eth', 'https://api.trinity-tech.cn/eth'],
	70: [getLlamaRpc("hoo"), 'https://http-mainnet.hoosmartchain.com'],
	32659: [getLlamaRpc("fusion"), 'https://mainnet.anyswap.exchange'],
	1313161554: [getLlamaRpc("aurora"), 'https://mainnet.aurora.dev'],
	2020: [getLlamaRpc("ronin"), 'https://api.roninchain.com/rpc'],
	288: [getLlamaRpc("boba"), 'https://mainnet.boba.network'],
	25: [
		getLlamaRpc("cronos"),
		'https://cronosrpc-1.xstaking.sg',
		'https://evm.cronos.org',
		'https://rpc.vvs.finance',
		'https://evm-cronos.crypto.org'
	],
	333999: [getLlamaRpc("polis"), 'https://rpc.polis.tech'],
	55: [
		getLlamaRpc("zyx"),
		'https://rpc-1.zyx.network',
		'https://rpc-2.zyx.network',
		'https://rpc-2.zyx.network',
		'https://rpc-5.zyx.network'
	],
	40: [getLlamaRpc("telos"), 'https://mainnet.telos.net/evm', 'https://rpc1.eu.telos.net/evm', 'https://rpc1.us.telos.net/evm'],
	1088: [getLlamaRpc("metis"), 'https://andromeda.metis.io/?owner=1088'],
	8: [getLlamaRpc("ubiq"), 'https://rpc.octano.dev'],
	106: [getLlamaRpc("velas"), 'https://evmexplorer.velas.com/rpc'],
	820: [getLlamaRpc("callisto"), 'https://rpc.callisto.network', 'https://clo-geth.0xinfra.com'],
	8217: [getLlamaRpc("klaytn"), 'https://public-node-api.klaytnapi.com/v1/cypress'],
	52: [
		getLlamaRpc("csc"),
		'https://rpc.coinex.net',
		'https://rpc1.coinex.net',
		'https://rpc2.coinex.net',
		'https://rpc3.coinex.net',
		'https://rpc4.coinex.net'
	],
	5551: [getLlamaRpc("nahmii"), 'https://l2.nahmii.io'],
	5050: [getLlamaRpc("liquidchain"), 'https://rpc.liquidchain.net', 'https://rpc.xlcscan.com'],
	82: [getLlamaRpc("meter"), 'https://rpc.meter.io'],
	361: [getLlamaRpc("theta"), 'https://eth-rpc-api.thetatoken.org/rpc'],
	42262: [getLlamaRpc("oasis"), 'https://emerald.oasis.dev'],
	57: [getLlamaRpc("syscoin"), 'https://rpc.syscoin.org'],
	1284: [getLlamaRpc("moonbeam"), 'https://rpc.api.moonbeam.network'],
	836542336838601: [getLlamaRpc("curio"), 'https://mainnet-api.skalenodes.com/v1/fit-betelgeuse'],
	592: [getLlamaRpc("astar"), 'https://evm.astar.network', 'https://rpc.astar.network:8545', 'https://astar.api.onfinality.io/public'],
	7700: [getLlamaRpc("canto"), 'https://canto.slingshot.finance', 'https://canto.neobase.one', 'https://mainnode.plexnode.org:8545'],
	324: [getLlamaRpc("era"), 'https://mainnet.era.zksync.io'],
	58: [getLlamaRpc("ontology_evm"), 'http://dappnode4.ont.io:20339', 'http://dappnode3.ont.io:20339'],
	1101: [getLlamaRpc("polygon_zkevm"), 'https://zkevm-rpc.com'],
	2222: [getLlamaRpc("kava"), 'https://evm2.kava.io'],
	369: [getLlamaRpc("pulse"), 'https://rpc.pulsechain.com'],
	8453: [getLlamaRpc("base"), 'https://mainnet.base.org', 'https://base-rpc.publicnode.com', 'https://base-mainnet.public.blastapi.io'],
	59144: [getLlamaRpc("linea"), 'https://rpc.linea.build'],
	534352: [getLlamaRpc("scroll"), 'https://rpc.scroll.io', 'https://scroll-mainnet.public.blastapi.io'],
	146: [getLlamaRpc("sonic"), 'https://rpc.soniclabs.com', 'https://sonic-rpc.publicnode.com']
};

export const rpcsTransports = Object.fromEntries(
	Object.entries(rpcUrls).map((chain: [string, Array<string>]) => [
		chain[0],
		fallback(uniq(chain[1]).map((rpc) => http(rpc, { timeout: 3_000 })))
	])
);

```

`interface/src/components/Aggregator/testAdapters.test.ts`:

```ts
import { chainsMap } from './constants';
import { getAllChains } from './router';
import { adapters } from './list';
import { redirectQuoteReq } from './adapters/utils';
import { nativeTokens } from './nativeTokens';
import { getTokenList } from '~/props/getTokenList';
import { zeroAddress } from 'viem';

/*
Test matrix
    - All chains
    - With wallet connected and without
    - Tokens and native gas coin

Checks:
    - Output amount is similar to other aggregators
    - Gas cost is not too low
*/

// Ghetto-mutex for rate limiting since we are testing 2*3*24 = 144 combinations
const locks = [] as ((value: unknown) => void)[];
function getLock() {
	return new Promise((resolve) => {
		locks.push(resolve);
	});
}
function releaseLock() {
	const firstLock = locks.shift();
	if (firstLock !== undefined) {
		firstLock(null);
	}
}
const CONCURRENT_TESTS = 5;

export async function testAdapters(addTest: (test: any) => void) {
	const allChains = getAllChains().map((c) => c.value);
	const allTokenlists = await getTokenList();
	setTimeout(() => new Array(CONCURRENT_TESTS).fill(null).map(releaseLock), 1e3); // Release locks in 1 sec
	await Promise.all(
		allChains.map(async (chain) => {
			const tokenlist = allTokenlists[chainsMap[chain]];
			if (tokenlist === undefined) {
				console.warn(`There's no tokenlist for ${chain}`);
				return;
			}
			const [_maybeNativeToken, token1, token2] = tokenlist;
			const nativeToken = nativeTokens.find((t) => t.chainId === chainsMap[chain]);
			const tokenCombinations = [
				// [from, to]
				[nativeToken, token1],
				[token2, nativeToken],
				[token1, token2]
			];
			await Promise.all(
				tokenCombinations.map(async (tokens) => {
					const fromAddresses = [
						zeroAddress,
						'0x000000000000000000000000000000000000dEaD' // Just used as a random address that has tokens (so we dont get balance errors)
					];
					await Promise.all(
						fromAddresses.map(async (userAddress) => {
							await getLock();
							const amount = '100' + '000000000000000000'; //100e18 -> 100 tokens
							const fromToken = tokens[0];
							const toToken = tokens[1];
							const extra = {
								gasPriceData: {
									gasPrice: Number('0x05d21dba00') // for yield yak, hardcoded to 25000000000n AVAX which was avax's gas price when I write this
								},
								userAddress,
								amount, // idk why this is here lol
								fromToken,
								toToken,
								slippage: 1,
								isPrivacyEnabled: false
							};
							const prices = (
								await Promise.all(
									adapters
										.filter((adap) => adap.chainToId[chain] !== undefined)
										.map(async (adapter) => {
											const testParams = {
												chain,
												from: fromToken.symbol,
												to: toToken.symbol,
												userAddress: userAddress === zeroAddress,
												privacy: extra.isPrivacyEnabled,
												adapter: adapter.name
											};
											try {
												let price;
												if (extra.isPrivacyEnabled) {
													price = await redirectQuoteReq(
														adapter.name,
														chain,
														fromToken.address,
														toToken.address,
														amount,
														extra
													);
												} else {
													price = await adapter.getQuote(chain, fromToken.address, toToken.address, amount, {
														...extra
													});
												}
												if (Number(price.estimatedGas) < 1000 && adapter.name !== 'CowSwap') {
													addTest({ ...testParams, price, success: 'gas' });
												}
												return { price, adapter: adapter.name, testParams };
											} catch (e) {
												addTest({ ...testParams, success: 'x' });
												console.error(`Failed to get data for ${adapter.name} on ${chain}`);
												return;
											}
										})
								)
							).filter((p) => p !== undefined);
							const reportUnder = (property: string) => {
								if (prices.length < 2) return;
								const sorted = prices.sort((a, b) => b!.price[property] - a!.price[property]);
								const mid = Math.round(prices.length / 2);
								const median = Number(sorted[mid]?.price[property] ?? 0);
								prices.forEach((p) => {
									if (!p || (property === 'estimatedGas' && p.adapter === 'CowSwap')) return;
									const value = Number(p.price[property]);
									if (value < 0.8 * median) {
										addTest({
											...p.testParams,
											success: property,
											value,
											median,
											drop: (100 * (median - value)) / median
										});
									}
								});
							};
							reportUnder('amountReturned');
							reportUnder('estimatedGas');
							releaseLock();
						})
					);
				})
			);
		})
	);
}

```

`interface/src/components/Aggregator/types.ts`:

```ts
export interface ExtraData {
	userAddress: string;
	slippage: string;
	amountOut: string;
}

```

`interface/src/components/Aggregator/utils/arbitrumFees.ts`:

```ts
import { readContract } from 'wagmi/actions';
import { config } from '../../WalletProvider';
import { arbitrum } from 'viem/chains';

export async function applyArbitrumFees(to: string, data: string, gas: string) {
	const gasData2 = await readContract(config, {
		address: '0x00000000000000000000000000000000000000C8',
		abi: [
			{
				inputs: [
					{ internalType: 'address', name: 'to', type: 'address' },
					{ internalType: 'bool', name: 'contractCreation', type: 'bool' },
					{ internalType: 'bytes', name: 'data', type: 'bytes' }
				],
				name: 'gasEstimateL1Component',
				outputs: [
					{ internalType: 'uint64', name: 'gasEstimateForL1', type: 'uint64' },
					{ internalType: 'uint256', name: 'baseFee', type: 'uint256' },
					{ internalType: 'uint256', name: 'l1BaseFeeEstimate', type: 'uint256' }
				],
				stateMutability: 'view',
				type: 'function'
			}
		],
		chainId: arbitrum.id,
		functionName: 'gasEstimateL1Component',
		args: [to as `0x${string}`, false, data as `0x${string}`]
	});

	return Number(BigInt(gas) + gasData2[0]).toString();
}

```

`interface/src/components/Aggregator/utils/getAllowance.ts`:

```ts
import { erc20Abi, zeroAddress } from 'viem';
import { readContract } from 'wagmi/actions';
import { config } from '~/components/WalletProvider';
import { chainsMap } from '../constants';

// To change the approve amount you first have to reduce the addresses`
//  allowance to zero by calling `approve(_spender, 0)` if it is not
//  already 0 to mitigate the race condition described here:
//  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
export const oldErc = [
	'0xdAC17F958D2ee523a2206206994597C13D831ec7'.toLowerCase(), // USDT
	'0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32'.toLowerCase() // LDO
];

export async function getAllowance({
	token,
	chain,
	address,
	spender
}: {
	token?: string;
	chain?: string;
	address?: `0x${string}`;
	spender?: `0x${string}`;
}) {
	if (!spender || !token || !address || token === zeroAddress || !chain) {
		return null;
	}
	try {
		const allowance = await readContract(config, {
			address: token as `0x${string}`,
			abi: erc20Abi,
			functionName: 'allowance',
			args: [address, spender],
			chainId: chainsMap[chain]
		});

		return allowance;
	} catch (error) {
		throw new Error(error instanceof Error ? `[Allowance]:${error.message}` : '[Allowance]: Failed to fetch allowance');
	}
}
```

`interface/src/components/Aggregator/utils/optimismFees.ts`:

```ts
import { readContract } from 'wagmi/actions';
import { config } from '../../WalletProvider';
import { chainsMap } from '../constants';

const FEE_ADDRESS = '0x420000000000000000000000000000000000000F';

export const chainsWithOpFees = ['optimism', 'base'];

export const getOptimismFee = async (txData, chain) => {
	if (!chain || !chainsMap[chain]) return 'Unknown';

	try {
		const gas = await readContract(config, {
			address: FEE_ADDRESS,
			abi: [
				{
					inputs: [{ internalType: 'bytes', name: '_data', type: 'bytes' }],
					name: 'getL1Fee',
					outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
					stateMutability: 'view',
					type: 'function'
				}
			],
			functionName: 'getL1Fee',
			args: [txData],
			chainId: chainsMap[chain]
		});

		return Number(gas) / 1e18;
	} catch (e) {
		console.log(e, txData);
		return 'Unknown';
	}
};

```

`interface/src/components/Aggregator/utils/sendTx.ts`:

```ts
import { estimateGas, sendTransaction } from 'wagmi/actions';
import { config } from '../../WalletProvider';

export async function sendTx(txObject: any) {
	if (txObject.data === '0x' || typeof txObject.to !== 'string') {
		throw new Error('Malformed tx'); // Should never happen
	}
	if (txObject.gas === undefined) {
		const gasPrediction = await estimateGas(config, txObject).catch(() => null);

		if (gasPrediction) {
			txObject.gas = (gasPrediction * 14n) / 10n; // Increase gas +40%
		}
	}

	return sendTransaction(config, txObject);
}

```

`interface/src/components/WalletProvider/chains.ts`:

```ts
import { Chain } from 'viem';
import { chainIconUrl } from '../Aggregator/nativeTokens';
import { rpcUrls } from '../Aggregator/rpcs';
import * as wagmiChains from 'viem/chains';

const okx = {
	...wagmiChains.okc,
	network: 'okexchain',
	iconUrl: chainIconUrl('oktchain'),
	iconBackground: '#000'
};

const binance = {
	...wagmiChains.bsc,
	network: 'bsc',
	iconUrl: chainIconUrl('binance'),
	iconBackground: '#000'
};

const boba = {
	...wagmiChains.boba,
	network: 'boba',
	iconUrl: chainIconUrl('boba'),
	iconBackground: '#000'
};

const harmony = {
	...wagmiChains.harmonyOne,
	network: 'harmony',
	iconUrl: chainIconUrl('harmony'),
	iconBackground: '#000'
};

const heco = {
	id: 128,
	name: 'Heco',
	network: 'heco',
	iconUrl: chainIconUrl('heco'),
	iconBackground: '#000',
	nativeCurrency: {
		decimals: 18,
		name: 'Huobi Token',
		symbol: 'HT'
	},
	rpcUrls: {
		default: { http: rpcUrls[128] }
	},
	blockExplorers: {
		default: {
			name: 'HecoScan',
			url: 'https://www.hecoinfo.com/en-us'
		}
	},
	testnet: false
};

const velas = {
	...wagmiChains.velas,
	network: 'velas',
	iconUrl: chainIconUrl('velas'),
	iconBackground: '#000'
};

const oasis = {
	id: 42262,
	name: 'Oasis',
	network: 'oasis',
	iconUrl: chainIconUrl('oasis'),
	iconBackground: '#000',
	nativeCurrency: {
		decimals: 18,
		name: 'Oasis',
		symbol: 'ROSE'
	},
	rpcUrls: {
		default: { http: rpcUrls[42262] }
	},
	blockExplorers: {
		default: { name: 'OasisScan', url: 'https://www.oasisscan.com' }
	},
	testnet: false
};

const moonbeam = {
	...wagmiChains.moonbeam,
	network: 'moonbeam',
	iconUrl: chainIconUrl('moonbeam'),
	iconBackground: '#000'
};

const fuse = {
	...wagmiChains.fuse,
	network: 'fuse',
	iconUrl: chainIconUrl('fuse'),
	iconBackground: '#000'
};

const moonriver = {
	...wagmiChains.moonriver,
	network: 'moonriver',
	iconUrl: chainIconUrl('moonriver'),
	iconBackground: '#000'
};

const cronos = {
	...wagmiChains.cronos,
	network: 'cronos',
	iconUrl: chainIconUrl('cronos'),
	iconBackground: '#000'
};
const celo = {
	...wagmiChains.celo,
	network: 'celo',
	iconUrl: chainIconUrl('celo'),
	iconBackground: '#000'
};
const aurora = {
	...wagmiChains.aurora,
	network: 'aurora',
	iconUrl: chainIconUrl('aurora'),
	iconBackground: '#000'
};
const avax = {
	...wagmiChains.avalanche,
	network: 'avax',
	iconUrl: chainIconUrl('avalanche'),
	iconBackground: '#000'
};

const klaytn = {
	...wagmiChains.klaytn,
	network: 'klaytn',
	iconUrl: chainIconUrl('klaytn'),
	iconBackground: '#000'
};
const fantom = {
	...wagmiChains.fantom,
	network: 'fantom',
	iconUrl: chainIconUrl('fantom'),
	iconBackground: '#000'
};

const gnosis = {
	...wagmiChains.gnosis,
	network: 'gnosis',
	iconUrl: chainIconUrl('gnosis'),
	iconBackground: '#000'
};
const polygon = {
	...wagmiChains.polygon,
	network: 'polygon',
	iconUrl: chainIconUrl('polygon'),
	iconBackground: '#000'
};

const canto = {
	...wagmiChains.canto,
	network: 'Canto',
	iconUrl: chainIconUrl('canto'),
	iconBackground: '#000'
};

const arbitrum = {
	...wagmiChains.arbitrum,
	network: 'arbitrum',
	iconUrl: chainIconUrl('arbitrum'),
	iconBackground: '#000'
};

const ethereum = {
	...wagmiChains.mainnet,
	network: 'ethereum',
	iconUrl: chainIconUrl('ethereum'),
	iconBackground: '#000'
};

const optimism = {
	...wagmiChains.optimism,
	network: 'optimism',
	iconUrl: chainIconUrl('optimism'),
	iconBackground: '#000'
};

const zksync = {
	...wagmiChains.zksync,
	network: 'zksync',
	iconUrl: chainIconUrl('zksync era'),
	iconBackground: '#000'
};

const ontology = {
	id: 58,
	name: 'OntologyEVM',
	network: 'ontology',
	iconUrl: chainIconUrl('OntologyEVM'),
	iconBackground: '#000',
	nativeCurrency: {
		decimals: 18,
		name: 'Ontology',
		symbol: 'ONT'
	},
	rpcUrls: {
		default: { http: rpcUrls[58] }
	},
	blockExplorers: {
		default: { name: 'Ontology Explorer', url: 'https://explorer.ont.io' }
	},
	testnet: false
};

const polygonZKEvm = {
	...wagmiChains.polygonZkEvm,
	network: 'polygonzkevm',
	iconUrl: chainIconUrl('Polygon zkEVM'),
	iconBackground: '#000'
};

const kava = {
	...wagmiChains.kava,
	network: 'kava',
	iconUrl: chainIconUrl('Kava'),
	iconBackground: '#000'
};

const metis = {
	...wagmiChains.metis,
	network: 'metis',
	iconUrl: chainIconUrl('metis'),
	iconBackground: '#000'
};

const pulse = {
	...wagmiChains.pulsechain,
	network: 'pulse',
	iconUrl: chainIconUrl('Pulse'),
	iconBackground: '#000'
};

const base = {
	...wagmiChains.base,
	network: 'base',
	iconUrl: chainIconUrl('Base'),
	iconBackground: '#000'
};

const linea = {
	...wagmiChains.linea,
	network: 'linea',
	iconUrl: chainIconUrl('Linea'),
	iconBackground: '#000'
};

const scroll = {
	...wagmiChains.scroll,
	network: 'scroll',
	iconUrl: chainIconUrl('Scroll'),
	iconBackground: '#000'
};

const sonic = {
	...wagmiChains.sonic,
	network: 'sonic',
	iconUrl: chainIconUrl('sonic'),
	iconBackground: '#000'
};

interface IChain extends Chain {
	network: string;
	iconUrl: string;
	iconBackground: string;
}

export const allChains: Array<IChain> = [
	ethereum,
	arbitrum,
	polygon,
	binance,
	optimism,
	base,
	avax,
	fantom,
	zksync,
	polygonZKEvm,
	linea,
	canto,
	gnosis,
	klaytn,
	aurora,
	cronos,
	celo,
	moonriver,
	heco,
	boba,
	okx,
	// bttc,
	// dogechain,
	moonbeam,
	fuse,
	oasis,
	ontology,
	kava,
	metis,
	pulse,
	velas,
	harmony,
	scroll,
	sonic
];

```

`interface/src/components/WalletProvider/index.ts`:

```ts
import { getDefaultConfig } from '@rainbow-me/rainbowkit';
import { rpcsTransports } from '../Aggregator/rpcs';
import { allChains } from './chains';
import type { Config } from 'wagmi';

const projectId = 'b3d4ba9fb97949ab12267b470a6f31d2';

export const config = getDefaultConfig({
	appName: 'LlamaSwap',
	projectId,
	chains: allChains as any,
	transports: rpcsTransports,
	ssr: false
}) as Config;

declare module 'wagmi' {
	interface Register {
		config: typeof config;
	}
}

```

`interface/src/constants/breakpoints.ts`:

```ts
export const sm = 480 / 16
export const med = 812 / 16
export const lg = 1024 / 16
export const xl = 1400 / 16
export const twoXl = 1536 / 16

```

`interface/src/hooks/index.ts`:

```ts
import { useState, useEffect } from 'react';

export const useIsClient = () => {
	const [isClient, setIsClient] = useState(false);

	const windowType = typeof window;

	useEffect(() => {
		if (windowType !== 'undefined') {
			setIsClient(true);
		}
	}, [windowType]);

	return isClient;
};

```

`interface/src/hooks/useCountdown.ts`:

```ts
import { useEffect, useState } from 'react';

const useCountdown = (targetDate) => {
	const countDownDate = new Date(targetDate).getTime();

	const [countDown, setCountDown] = useState(countDownDate - new Date().getTime());

	useEffect(() => {
		const interval = setInterval(() => {
			setCountDown(countDownDate - new Date().getTime());
		}, 1000);

		return () => clearInterval(interval);
	}, [countDownDate]);

	const seconds = Math.floor((countDown % (1000 * 60)) / 1000);

	return seconds < 0 || Number.isNaN(seconds) ? 0 : seconds;
};

function useCountdownFull(msTillTraget) {
	const [millisecondsTillTargetTime, setMillisecondsTillTargetTime] = useState(msTillTraget);
	const [isStarted, setStarted] = useState(false);

	useEffect(() => {
		if (isStarted) {
			setMillisecondsTillTargetTime(msTillTraget);
			const interval = setInterval(() => {
				setMillisecondsTillTargetTime((ms) => ms - 1000);
			}, 1000);

			return () => clearInterval(interval);
		}
		return;
	}, [msTillTraget]);

	const start = () => setStarted(true);

	return { countdown: getReturnValues(millisecondsTillTargetTime), start, isStarted };
}

const getReturnValues = (millisecondsTillTargetTime) => {
	const days = round(millisecondsTillTargetTime / (1000 * 60 * 60 * 24));
	const hours = round((millisecondsTillTargetTime % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
	const minutes = round((millisecondsTillTargetTime % (1000 * 60 * 60)) / (1000 * 60));
	const seconds = round((millisecondsTillTargetTime % (1000 * 60)) / 1000);

	return { days, hours, minutes, seconds };
};

function round(value) {
	if (value > 0) {
		return Math.floor(value);
	}
	return Math.ceil(value);
}

export { useCountdown, useCountdownFull };

```

`interface/src/props/getLendingProps.ts`:

```ts
import { IPool } from '~/types';

export async function getLSDPageData(pools) {
	const [{ protocols }] = await Promise.all(
		['https://api.llama.fi/lite/protocols2?b=2'].map((url) => fetch(url).then((r) => r.json()))
	);

	// filter for LSDs
	const lsdProtocols = protocols
		.filter((p) => p.category === 'Liquid Staking' && p.chains.includes('Ethereum'))
		.map((p) => p.name)
		.filter((p) => !['StakeHound', 'Genius', 'SharedStake'].includes(p))
		.concat('Crypto.com Staked ETH');

	// get historical data
	const lsdProtocolsSlug = lsdProtocols.map((p) => p.replace(/\s+/g, '-').toLowerCase());

	let lsdApy = pools
		.filter((p) => lsdProtocolsSlug.includes(p.project) && p.chain === 'Ethereum' && p.symbol.includes('ETH'))
		.concat(pools.find((i) => i.project === 'crypto.com-staked-eth'))
		.map((p) => ({
			...p,
			name: p.project
				.split('-')
				.map((i) =>
					i === 'stakewise' ? 'StakeWise' : i === 'eth' ? i.toUpperCase() : i.charAt(0).toUpperCase() + i.slice(1)
				)
				.join(' ')
		}));

	return lsdApy;
}

async function getLendBorrowData(pools: Array<IPool> = []) {
	const yieldsConfig = await fetch('https://api.llama.fi/config/yields')
		.then((res) => res.json())
		.then((c) => c.protocols);

	const lsdData = await getLSDPageData(pools);
	pools.forEach((pool) => {
		pool.config = yieldsConfig[pool.project];
		pool.category = pool?.config?.category || '';
	});

	pools = pools.map((p) => ({
		...p,
		category: p.project === 'fraxlend' ? 'CDP' : p.category,
		apyBase: p.project === 'fraxlend' ? null : p.apyBase
	}));

	const categoriesToKeep = ['Lending', 'Undercollateralized Lending', 'CDP', 'NFT Lending'];
	pools = pools.filter((p) => categoriesToKeep.includes(p.category));

	let dataBorrow = await fetch('https://yields.llama.fi/lendBorrow').then((res) => res.json());
	dataBorrow = dataBorrow.filter((p) => p.ltv <= 1);

	const configIdsCompound = pools.filter((p) => p.project === 'compound').map((p) => p.pool);
	const configIdsAave = pools
		.filter((p) => p.project === 'aave-v2' && p.chain === 'Ethereum' && !p.symbol.toLowerCase().includes('amm'))
		.map((p) => p.pool);
	const compoundPools = dataBorrow.filter((p) => configIdsCompound.includes(p.pool));
	const aavev2Pools = dataBorrow.filter((p) => configIdsAave.includes(p.pool));

	const tokenSymbols = new Set<string>();
	const cdpPools = [...new Set(pools.filter((p) => p.category === 'CDP').map((p) => p.pool))];
	pools = pools
		.map((p) => {
			const x = dataBorrow.find((i) => i.pool === p.pool);
			if (x === undefined) return null;

			tokenSymbols.add(p.symbol);
			if (x?.mintedCoin) tokenSymbols.add(x.mintedCoin);

			const apyBaseBorrow = x.apyBaseBorrow !== null ? -x.apyBaseBorrow : null;
			const apyRewardBorrow = x.apyRewardBorrow;
			const apyBorrow = apyBaseBorrow === null && apyRewardBorrow === null ? null : apyBaseBorrow + apyRewardBorrow;
			const isBorrowable = x.borrowable || x.totalBorrowUsd > 0;
			const lsdApy =
				lsdData.find((i) => p?.symbol?.toLowerCase().includes(i.symbol?.toLowerCase()) && !p.symbol?.includes('-'))
					?.apy || 0;
			let totalAvailableUsd;
			if (p.project === 'morpho-compound') {
				const compoundData = compoundPools.find(
					(a) => a.underlyingTokens[0].toLowerCase() === x.underlyingTokens[0].toLowerCase()
				);
				totalAvailableUsd = compoundData?.totalSupplyUsd - compoundData?.totalBorrowUsd;
			} else if (p.project === 'morpho-aave') {
				const aaveData = aavev2Pools.find(
					(a) => a.underlyingTokens[0].toLowerCase() === x.underlyingTokens[0].toLowerCase()
				);
				totalAvailableUsd = aaveData?.totalSupplyUsd - aaveData?.totalBorrowUsd;
			} else if (x.totalSupplyUsd === null && x.totalBorrowUsd === null) {
				totalAvailableUsd = null;
			} else if (cdpPools.includes(x.pool)) {
				totalAvailableUsd = x.debtCeilingUsd ? x.debtCeilingUsd - x.totalBorrowUsd : null;
			} else if (p.project === 'compound' && x.debtCeilingUsd > 0) {
				totalAvailableUsd =
					x.totalSupplyUsd - x.totalBorrowUsd > x.debtCeilingUsd
						? x.debtCeilingUsd
						: x.totalSupplyUsd - x.totalBorrowUsd;
			} else {
				totalAvailableUsd = x.totalSupplyUsd - x.totalBorrowUsd;
			}

			return {
				...p,
				apy: p.apy + lsdApy,
				lsdApy,
				apu: p.apy,
				apyBaseBorrow,
				apyRewardBorrow,
				totalSupplyUsd: x.totalSupplyUsd,
				totalBorrowUsd: x.totalBorrowUsd,
				ltv: x.ltv,
				borrowable: isBorrowable,
				mintedCoin: x.mintedCoin,
				borrowFactor: x.borrowFactor,
				totalAvailableUsd,
				apyBorrow,
				rewardTokens: (p.apyReward ?? 0) > 0 || x.apyRewardBorrow > 0 ? x.rewardTokens : p.rewardTokens
			};
		})
		.filter(Boolean)
		.sort((a, b) => b!.totalSupplyUsd - a!.totalSupplyUsd) as Array<IPool>;

	return {
		yields: pools,
		chainList: [...new Set(pools.map((p) => p.chain))],
		categoryList: categoriesToKeep,
		allPools: pools,
		lsdData,
		tokens: [...tokenSymbols].map((s) => ({ name: s, symbol: s }))
	};
}

export async function getLendingProps() {
	const yields = await fetch('https://yields.llama.fi/pools')
		.then((res) => res.json())
		.then((res) => res.data);
	const lendingData = await getLendBorrowData(yields);
	return lendingData;
}

```

`interface/src/props/getSandwichList.ts`:

```ts
import { chunk } from 'lodash';
import { normalizeTokens } from '~/utils';
import { getTopTokensByChain } from './getTokenList';

const LIQUDITY_THRESHOLD_USD = 1_500_000;
const PERCENT_SANDWICHED_TRADES = 5;

export const getSandwichList = async () => {
	try {
		const { data: sandwichData } = await fetch(
			`https://public.api.eigenphi.io/?path=/ethereum/30d/sandwiched_pool&apikey=${process.env.EIGEN_API_KEY}`
		).then((res) => res.json());

		const [_, topTokens] = await getTopTokensByChain(1);

		const topPairs =
			topTokens
				?.filter((pair) => Number(pair?.attributes?.reserve_in_usd) > LIQUDITY_THRESHOLD_USD)
				.reduce(
					(acc, pair) => ({
						...acc,
						[(normalizeTokens(pair.token0?.address, pair?.token1?.address) as Array<string>).join('')]: true
					}),
					{}
				) ?? {};

		const poolAddresses = chunk(
			sandwichData?.map(({ address }) => address),
			30
		);
		const pairsData = (
			await Promise.allSettled(
				poolAddresses.map(
					async (pools) =>
						await fetch(`https://api.dexscreener.com/latest/dex/pairs/ethereum/${pools.join(',')}`).then((r) =>
							r.json()
						)
				)
			)
		)
			.filter(({ status }) => status === 'fulfilled')
			.map(({ value }: any) => value.pairs)
			.flat()
			.sort((a, b) => b.liquidity?.usd - a?.liquidity?.usd);

		const highLiqPairs = pairsData
			.filter((pair) => pair?.liquidity?.usd > LIQUDITY_THRESHOLD_USD)
			.map((pair) => ({
				...pair,
				id: (normalizeTokens(pair?.baseToken?.address, pair?.quoteToken?.address) as Array<string>).join('')
			}));

		const sandwichList = {
			ethereum: pairsData.reduce((acc, pair) => {
				const pairData = sandwichData.find(({ address }) => address.toLowerCase() === pair?.pairAddress?.toLowerCase());
				const pairId = (
					normalizeTokens(pairData?.tokens[0]?.address, pairData?.tokens[1]?.address) as Array<string>
				).join('');
				if (
					!pairData ||
					(pairData.sandwiched / pairData.trades) * 100 < PERCENT_SANDWICHED_TRADES ||
					topPairs[pairId] ||
					highLiqPairs.find(({ id }) => id === pairId)
				)
					return acc;

				return { ...acc, [pairId]: pairData };
			}, {})
		};

		return sandwichList;
	} catch (e) {
		console.log(e);
		return [];
	}
};

```

`interface/src/props/getTokenList.ts`:

```ts
import { geckoTerminalChainsMap } from '~/components/Aggregator/constants';

export async function getTokenList(chainId?: number) {
	return fetch(chainId ? `https://d3g10bzo9rdluh.cloudfront.net/tokenlists-${chainId}.json` : `https://d3g10bzo9rdluh.cloudfront.net/tokenlists.json`).then((r) => r.json());
}

export const getTopTokensByChain = async (chainId) => {
	try {
		if (!geckoTerminalChainsMap[chainId]) {
			return [chainId, []];
		}

		const resData: any[] = [];

		for (let i = 1; i <= 5; i++) {
			const prevRes = await fetch(
				`https://api.geckoterminal.com/api/v2/networks/${geckoTerminalChainsMap[chainId]}/pools?include=dex%2Cdex.network%2Cdex.network.network_metric%2Ctokens&page=${i}&include_network_metrics=true`
			)
				.then((r) => r.json())
				.catch(() => ({ data: [], included: [] }));

			resData.push(...prevRes.data);
		}

		const result = resData.map((pool) => {
			return { ...pool, baseToken: pool.relationships.base_token.data.id.split('_')[1] };
		});

		return [chainId, result];
	} catch (error) {
		return [chainId, []];
	}
};

```

`interface/src/props/getTokensMaps.ts`:

```ts
import { IToken } from '~/types';

const mapTokensByKey = (tokens: Record<string, Array<IToken>>, key: Array<string>) => {
	return Object.fromEntries(
		Object.entries(tokens).map(([chain, tokens]) => {
			return [
				chain,
				Object.fromEntries(
					tokens
						.map((token) => {
							const value = key.map((k) => token[k]).filter(Boolean)[0];

							return value ? [token.address.toLowerCase(), value] : null;
						})
						.filter(Boolean) as Array<[string, string]>
				)
			];
		})
	);
};

export const getTokensMaps = (tokenlist) => {
	const tokensUrlMap = mapTokensByKey(tokenlist, ['logoURI', 'logoURI2']);
	const tokensSymbolsMap = mapTokensByKey(tokenlist, ['symbol']);

	return { tokensUrlMap, tokensSymbolsMap };
};

```

`interface/src/props/getYieldsProps.ts`:

```ts
export async function getYieldsProps() {
	const yields = await fetch('https://yields.llama.fi/pools')
		.then((res) => res.json())
		.then((res) => res.data)
		.then((pools) => pools.filter((pool) => pool?.ilRisk === 'no'));
	const yieldsConfig = await fetch('https://api.llama.fi/config/yields')
		.then((res) => res.json())
		.then((c) => c.protocols);

	return {
		data: yields,
		config: yieldsConfig
	};
}

```

`interface/src/types.ts`:

```ts
export interface IToken {
	address: string;
	label: string;
	value: string;
	logoURI: string;
	logoURI2?: string | null;
	symbol: string;
	decimals: number;
	name: string;
	chainId: number;
	amount?: string | number;
	balanceUSD?: number;
	geckoId: string | null;
	isGeckoToken?: boolean;
	isMultichain?: boolean;
}

export interface IPool {
	apu: number;
	apy: number;
	apyBase: number | null;
	apyBase7d: number | null;
	apyBaseBorrow: number;
	apyBaseInception: number | null;
	apyBorrow: number;
	apyMean30d: number;
	apyPct1D: number;
	apyPct7D: number;
	apyPct30D: number;
	apyReward: number | null;
	apyRewardBorrow: number | null;
	borrowFactor: null;
	borrowable: true;
	category: string;
	chain: string;
	count: number;
	exposure: string;
	il7d: number | null;
	ilRisk: string;
	lsdApy: number;
	ltv: number;
	mintedCoin: string | null;
	mu: number;
	outlier: boolean;
	pool: string;
	poolMeta: null;
	predictions: { predictedClass: string; predictedProbability: number; binnedConfidence: number };
	project: string;
	rewardTokens: null;
	sigma: number;
	stablecoin: boolean;
	symbol: string;
	totalAvailableUsd: number;
	totalBorrowUsd: number;
	totalSupplyUsd: number;
	tvlUsd: number;
	underlyingTokens: Array<string>;
	volumeUsd1d: number | null;
	volumeUsd7d: number | null;
	config: { name: string; category: string };
}

```

`interface/src/utils/formatAmount.ts`:

```ts
export const formatAmount = (amount: string | number) => amount.toString().trim().split(' ').join('');

export const formatAmountString = (value, prefix = '') => {
	if (isNaN(value)) return value;
	const formatter = Intl.NumberFormat('en', { notation: 'compact' });
	return prefix + formatter.format(value);
};

```

`interface/src/utils/formatToast.ts`:

```ts
import BigNumber from 'bignumber.js';

export const formatSuccessToast = (variables) => {
	const fromToken = variables.tokens.fromToken;
	const toToken = variables.tokens.toToken;

	const inAmount = variables.rawQuote?.inAmount ?? variables.rawQuote?.inputAmount ?? variables.rawQuote?.sellAmount;
	const outAmount = variables.rawQuote?.outAmount ?? variables.rawQuote?.outputAmount ?? variables.rawQuote?.buyAmount;
	return {
		title: 'Transaction Success',
		description: `Swapped ${
			inAmount
				? BigNumber(inAmount)
						.div(10 ** Number(fromToken.decimals || 18))
						.toFixed(3)
				: ''
		} ${fromToken.symbol} for ${
			outAmount
				? BigNumber(outAmount)
						.div(10 ** Number(toToken.decimals || 18))
						.toFixed(3)
				: ''
		} ${toToken.symbol} via ${variables.adapter}`,
		status: 'success',
		duration: 10000,
		isClosable: true,
		position: 'top-right',
		containerStyle: {
			width: '100%',
			maxWidth: '300px'
		}
	} as const;
};

const SLIPPAGE_ERRORS = [
	'<minTotalAmountOut',
	'ERR_LIMIT_OUT',
	'Return amount is not enough',
	'Received amount of tokens are less then expected'
];

export const formatErrorToast = (error, isFailed = false) => {
	const isSlippage = SLIPPAGE_ERRORS.some((text) => error?.reason?.includes(text));
	let errorMsg = 'Something went wrong';

	if (isFailed) errorMsg = 'Transaction Failed';
	else if (isSlippage) errorMsg = 'Slippage is too low, try again with higher slippage';
	else if (error?.reason) errorMsg = error.reason;

	return {
		title: 'Transaction Failed',
		description: errorMsg,
		status: 'error',
		duration: 10000,
		isClosable: true,
		position: 'top-right',
		containerStyle: {
			width: '100%',
			maxWidth: '300px'
		}
	} as const;
};

export const formatUnknownErrorToast = ({ title, message }) => {
	return {
		title: title,
		description: message,
		status: 'error',
		duration: 10000,
		isClosable: true,
		position: 'top-right',
		containerStyle: {
			width: '100%',
			maxWidth: '300px'
		}
	} as const;
};

export const formatSubmittedToast = (variables) => {
	const fromToken = variables.tokens.fromToken;
	const toToken = variables.tokens.toToken;

	const inAmount = variables.rawQuote?.inAmount ?? variables.rawQuote?.inputAmount ?? variables.rawQuote?.sellAmount;
	const outAmount = variables.rawQuote?.outAmount ?? variables.rawQuote?.outputAmount ?? variables.rawQuote?.buyAmount;
	return {
		title: 'Transaction Submitted',
		description: `Swap ${
			inAmount
				? BigNumber(inAmount)
						.div(10 ** Number(fromToken.decimals || 18))
						.toFixed(3)
				: ''
		} ${fromToken.symbol} for ${
			outAmount
				? BigNumber(outAmount)
						.div(10 ** Number(toToken.decimals || 18))
						.toFixed(3)
				: ''
		} ${toToken.symbol} via ${variables.adapter}`,
		status: 'success',
		duration: 10000,
		isClosable: true,
		position: 'top-right',
		containerStyle: {
			width: '100%',
			maxWidth: '300px'
		}
	} as const;
};

```